# ‚úÖ Paso 85: Integrar Gobernanza con Tally para Propuestas Ejecutables On-Chain

Implementaremos un sistema completo de gobernanza descentralizada usando Tally, donde las decisiones votadas en la DAO se ejecutan autom√°ticamente como transacciones en la blockchain.

## üéØ Tecnolog√≠as Integradas

‚úÖ **Votaciones Ejecutables** ‚Üí Las decisiones en la DAO afectan contratos en Ethereum autom√°ticamente  
‚úÖ **Tally + OpenZeppelin Governor** ‚Üí Implementaci√≥n est√°ndar y segura de gobernanza on-chain  
‚úÖ **Web3.js + Stimulus.js** ‚Üí Para crear y votar propuestas desde la UI de Rails  
‚úÖ **Smart Contract de Gobernanza en Solidity** ‚Üí Para gestionar votaciones y ejecutar cambios  
‚úÖ **Timelock Controller** ‚Üí Retraso de seguridad para propuestas cr√≠ticas  
‚úÖ **Delegation System** ‚Üí Sistema de delegaci√≥n de poder de voto  

## üìå Commit 85.1: Crear Smart Contract de Gobernanza con OpenZeppelin Governor

üîπ **Mensaje de commit:**
```
feat(tally-governance): agrega smart contract para gobernanza on-chain en la DAO con Tally
```

üîπ **Contenido del commit:**

**Instalar dependencias Hardhat:**
```bash
npm install --save-dev hardhat @nomiclabs/hardhat-ethers ethers
npm install @openzeppelin/contracts @openzeppelin/contracts-upgradeable
```

**Crear** `contracts/TallyGovernor.sol`:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/governance/Governor.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title TallyGovernor
 * @dev A comprehensive governance contract for the DAO with Tally integration
 * Features:
 * - Voting with ERC20Votes token
 * - Quorum requirements (4% of total supply)
 * - Timelock for proposal execution
 * - Configurable voting parameters
 * - Emergency proposal cancellation
 */
contract TallyGovernor is
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl,
    Ownable
{
    // Events for better monitoring
    event ProposalCreatedWithMetadata(
        uint256 proposalId,
        address proposer,
        string description,
        string metadataURI
    );
    
    event EmergencyProposalCancelled(uint256 proposalId, string reason);
    
    event GovernanceParametersUpdated(
        uint256 newVotingDelay,
        uint256 newVotingPeriod,
        uint256 newProposalThreshold
    );

    // Governance parameters
    uint256 private _votingDelay;
    uint256 private _votingPeriod;
    uint256 private _proposalThreshold;
    
    // Emergency controls
    mapping(uint256 => bool) public emergencyCancelled;
    
    // Proposal metadata storage
    mapping(uint256 => string) public proposalMetadata;

    constructor(
        IVotes _token,
        TimelockController _timelock,
        uint256 _initialVotingDelay,
        uint256 _initialVotingPeriod,
        uint256 _initialProposalThreshold,
        uint256 _quorumPercentage
    )
        Governor("TallyGovernor")
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(_quorumPercentage)
        GovernorTimelockControl(_timelock)
        GovernorSettings(_initialVotingDelay, _initialVotingPeriod, _initialProposalThreshold)
    {
        _votingDelay = _initialVotingDelay;
        _votingPeriod = _initialVotingPeriod;
        _proposalThreshold = _initialProposalThreshold;
    }

    // Override required functions
    function votingDelay() public view override(IGovernor, GovernorSettings) returns (uint256) {
        return GovernorSettings.votingDelay();
    }

    function votingPeriod() public view override(IGovernor, GovernorSettings) returns (uint256) {
        return GovernorSettings.votingPeriod();
    }

    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {
        return GovernorSettings.proposalThreshold();
    }

    function quorum(uint256 blockNumber)
        public
        view
        override(IGovernor, GovernorVotesQuorumFraction)
        returns (uint256)
    {
        return GovernorVotesQuorumFraction.quorum(blockNumber);
    }

    function state(uint256 proposalId)
        public
        view
        override(Governor, GovernorTimelockControl)
        returns (ProposalState)
    {
        if (emergencyCancelled[proposalId]) {
            return ProposalState.Canceled;
        }
        return GovernorTimelockControl.state(proposalId);
    }

    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public override(Governor, IGovernor) returns (uint256) {
        return super.propose(targets, values, calldatas, description);
    }

    function proposeWithMetadata(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description,
        string memory metadataURI
    ) public returns (uint256) {
        uint256 proposalId = propose(targets, values, calldatas, description);
        
        proposalMetadata[proposalId] = metadataURI;
        
        emit ProposalCreatedWithMetadata(
            proposalId,
            _msgSender(),
            description,
            metadataURI
        );
        
        return proposalId;
    }

    function emergencyCancel(uint256 proposalId, string memory reason)
        external
        onlyOwner
    {
        require(
            state(proposalId) == ProposalState.Pending ||
            state(proposalId) == ProposalState.Active,
            "TallyGovernor: proposal not active"
        );
        
        emergencyCancelled[proposalId] = true;
        
        emit EmergencyProposalCancelled(proposalId, reason);
    }

    function updateGovernanceParameters(
        uint256 newVotingDelay,
        uint256 newVotingPeriod,
        uint256 newProposalThreshold
    ) external onlyOwner {
        _setVotingDelay(newVotingDelay);
        _setVotingPeriod(newVotingPeriod);
        _setProposalThreshold(newProposalThreshold);
        
        emit GovernanceParametersUpdated(
            newVotingDelay,
            newVotingPeriod,
            newProposalThreshold
        );
    }

    function getProposalMetadata(uint256 proposalId)
        external
        view
        returns (string memory)
    {
        return proposalMetadata[proposalId];
    }

    function _execute(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) {
        require(!emergencyCancelled[proposalId], "TallyGovernor: proposal emergency cancelled");
        super._execute(proposalId, targets, values, calldatas, descriptionHash);
    }

    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }

    function _executor()
        internal
        view
        override(Governor, GovernorTimelockControl)
        returns (address)
    {
        return super._executor();
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(Governor, GovernorTimelockControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

**Crear** `contracts/GovernanceToken.sol`:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title GovernanceToken (GOVR)
 * @dev ERC20 token with voting capabilities for DAO governance
 */
contract GovernanceToken is ERC20, ERC20Permit, ERC20Votes, Ownable {
    uint256 public constant MAX_SUPPLY = 100_000_000 * 10**18; // 100M tokens
    
    constructor() 
        ERC20("GovernanceToken", "GOVR") 
        ERC20Permit("GovernanceToken") 
    {
        // Mint initial supply to deployer
        _mint(msg.sender, 10_000_000 * 10**18); // 10M initial supply
    }

    function mint(address to, uint256 amount) external onlyOwner {
        require(totalSupply() + amount <= MAX_SUPPLY, "GovernanceToken: exceeds max supply");
        _mint(to, amount);
    }

    // The following functions are overrides required by Solidity
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }

    function _mint(address to, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._mint(to, amount);
    }

    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {
        super._burn(account, amount);
    }
}
```

**Crear script de deploy** `scripts/deploy-governance.js`:
```javascript
const { ethers } = require("hardhat");

async function main() {
  console.log("Deploying Governance system...");

  // Deploy Governance Token
  const GovernanceToken = await ethers.getContractFactory("GovernanceToken");
  const governanceToken = await GovernanceToken.deploy();
  await governanceToken.deployed();
  console.log("GovernanceToken deployed to:", governanceToken.address);

  // Deploy Timelock Controller
  const TimelockController = await ethers.getContractFactory("TimelockController");
  const minDelay = 2 * 24 * 60 * 60; // 2 days
  const proposers = []; // Will be set to governor after deployment
  const executors = []; // Will be set to governor after deployment
  const admin = ethers.constants.AddressZero; // No admin (fully decentralized)
  
  const timelock = await TimelockController.deploy(
    minDelay,
    proposers,
    executors,
    admin
  );
  await timelock.deployed();
  console.log("TimelockController deployed to:", timelock.address);

  // Deploy Governor
  const TallyGovernor = await ethers.getContractFactory("TallyGovernor");
  const votingDelay = 1; // 1 block
  const votingPeriod = 17280; // ~3 days (assuming 15s block time)
  const proposalThreshold = ethers.utils.parseEther("1000"); // 1000 GOVR tokens
  const quorumPercentage = 4; // 4%

  const governor = await TallyGovernor.deploy(
    governanceToken.address,
    timelock.address,
    votingDelay,
    votingPeriod,
    proposalThreshold,
    quorumPercentage
  );
  await governor.deployed();
  console.log("TallyGovernor deployed to:", governor.address);

  // Setup roles
  const proposerRole = await timelock.PROPOSER_ROLE();
  const executorRole = await timelock.EXECUTOR_ROLE();
  const timelockAdminRole = await timelock.TIMELOCK_ADMIN_ROLE();

  // Grant roles to governor
  await timelock.grantRole(proposerRole, governor.address);
  await timelock.grantRole(executorRole, governor.address);
  
  // Grant executor role to everyone (for execution after timelock)
  await timelock.grantRole(executorRole, ethers.constants.AddressZero);

  console.log("Governance system deployed successfully!");
  console.log({
    governanceToken: governanceToken.address,
    timelock: timelock.address,
    governor: governor.address
  });

  return {
    governanceToken,
    timelock,
    governor
  };
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

## üìå Commit 85.2: Integrar Tally API y Services

üîπ **Mensaje de commit:**
```
feat(tally-governance): integra API de Tally para sincronizaci√≥n de propuestas
```

**Crear** `app/services/tally_api_service.rb`:
```ruby
class TallyApiService
  include HTTParty
  
  base_uri 'https://api.tally.xyz'
  
  def self.get_dao_proposals(dao_slug)
    response = get("/query", {
      query: {
        query: proposals_query,
        variables: { 
          chainId: "eip155:1", # Ethereum mainnet
          governorId: dao_slug 
        }.to_json
      },
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': Rails.application.credentials.dig(:tally, :api_key)
      }
    })
    
    if response.success?
      response.parsed_response.dig('data', 'proposals', 'nodes') || []
    else
      Rails.logger.error "Tally API Error: #{response.code} - #{response.message}"
      []
    end
  end

  def self.get_proposal_details(proposal_id)
    response = get("/query", {
      query: {
        query: proposal_details_query,
        variables: { id: proposal_id }.to_json
      },
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': Rails.application.credentials.dig(:tally, :api_key)
      }
    })
    
    if response.success?
      response.parsed_response.dig('data', 'proposal')
    else
      Rails.logger.error "Tally API Error: #{response.code} - #{response.message}"
      nil
    end
  end

  def self.get_voting_power(dao_slug, address, block_number = nil)
    response = get("/query", {
      query: {
        query: voting_power_query,
        variables: {
          chainId: "eip155:1",
          governorId: dao_slug,
          voterAddress: address,
          blockNumber: block_number
        }.to_json
      },
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': Rails.application.credentials.dig(:tally, :api_key)
      }
    })
    
    if response.success?
      response.parsed_response.dig('data', 'votingPower', 'amount') || "0"
    else
      Rails.logger.error "Tally API Error: #{response.code} - #{response.message}"
      "0"
    end
  end

  private

  def self.proposals_query
    <<~GRAPHQL
      query GetProposals($chainId: ChainID!, $governorId: AccountID!) {
        proposals(
          chainId: $chainId
          governorId: $governorId
          sort: { field: START_BLOCK, order: DESC }
        ) {
          nodes {
            id
            title
            description
            proposer {
              address
            }
            status
            startBlock
            endBlock
            quorum
            proposalStats {
              votes
              weight
              forCount
              againstCount
              abstainCount
            }
            executableCalls {
              target
              value
              calldata
            }
          }
        }
      }
    GRAPHQL
  end

  def self.proposal_details_query
    <<~GRAPHQL
      query GetProposal($id: ID!) {
        proposal(id: $id) {
          id
          title
          description
          proposer {
            address
            name
          }
          status
          startBlock
          endBlock
          quorum
          proposalStats {
            votes
            weight
            forCount
            againstCount
            abstainCount
          }
          executableCalls {
            target
            value
            calldata
            signature
          }
          votes {
            nodes {
              voter {
                address
                name
              }
              support
              weight
              reason
            }
          }
        }
      }
    GRAPHQL
  end

  def self.voting_power_query
    <<~GRAPHQL
      query GetVotingPower($chainId: ChainID!, $governorId: AccountID!, $voterAddress: Address!, $blockNumber: Int) {
        votingPower(
          chainId: $chainId
          governorId: $governorId
          voterAddress: $voterAddress
          blockNumber: $blockNumber
        ) {
          amount
        }
      }
    GRAPHQL
  end
end
```

**Crear** `app/services/governance_service.rb`:
```ruby
class GovernanceService
  GOVERNOR_CONTRACT_ADDRESS = Rails.application.credentials.dig(:governance, :governor_address)
  GOVERNANCE_TOKEN_ADDRESS = Rails.application.credentials.dig(:governance, :token_address)
  
  def self.create_proposal(proposer_address, targets, values, calldatas, description, metadata_uri = nil)
    begin
      # Store proposal in database
      proposal = Proposal.create!(
        proposer_address: proposer_address,
        title: extract_title_from_description(description),
        description: description,
        metadata_uri: metadata_uri,
        targets: targets,
        values: values,
        calldatas: calldatas,
        status: 'pending',
        blockchain_id: nil # Will be updated when transaction is mined
      )

      # Return data for frontend to submit transaction
      {
        success: true,
        proposal_id: proposal.id,
        transaction_data: {
          to: GOVERNOR_CONTRACT_ADDRESS,
          data: encode_propose_call(targets, values, calldatas, description)
        }
      }
    rescue => e
      Rails.logger.error "Error creating proposal: #{e.message}"
      { success: false, error: e.message }
    end
  end

  def self.vote_on_proposal(voter_address, proposal_id, support, reason = nil)
    begin
      proposal = Proposal.find(proposal_id)
      
      unless proposal.blockchain_id
        return { success: false, error: "Proposal not yet on blockchain" }
      end

      # Check if user already voted
      existing_vote = Vote.find_by(
        proposal: proposal,
        voter_address: voter_address.downcase
      )

      if existing_vote
        return { success: false, error: "Already voted on this proposal" }
      end

      # Store vote in database
      vote = Vote.create!(
        proposal: proposal,
        voter_address: voter_address.downcase,
        support: support,
        reason: reason,
        voting_power: get_voting_power(voter_address, proposal.start_block)
      )

      {
        success: true,
        vote_id: vote.id,
        transaction_data: {
          to: GOVERNOR_CONTRACT_ADDRESS,
          data: encode_vote_call(proposal.blockchain_id, support)
        }
      }
    rescue => e
      Rails.logger.error "Error voting on proposal: #{e.message}"
      { success: false, error: e.message }
    end
  end

  def self.execute_proposal(proposal_id)
    begin
      proposal = Proposal.find(proposal_id)
      
      unless proposal.blockchain_id
        return { success: false, error: "Proposal not yet on blockchain" }
      end

      unless proposal.status == 'succeeded'
        return { success: false, error: "Proposal cannot be executed" }
      end

      {
        success: true,
        transaction_data: {
          to: GOVERNOR_CONTRACT_ADDRESS,
          data: encode_execute_call(
            proposal.targets,
            proposal.values,
            proposal.calldatas,
            proposal.description
          )
        }
      }
    rescue => e
      Rails.logger.error "Error executing proposal: #{e.message}"
      { success: false, error: e.message }
    end
  end

  def self.sync_with_tally
    dao_slug = Rails.application.credentials.dig(:tally, :dao_slug)
    return unless dao_slug

    tally_proposals = TallyApiService.get_dao_proposals(dao_slug)
    
    tally_proposals.each do |tally_proposal|
      sync_proposal_from_tally(tally_proposal)
    end
  end

  def self.get_voting_power(address, block_number = nil)
    # This would integrate with Web3 to get actual voting power
    # For now, return a placeholder
    "1000000000000000000" # 1 token
  end

  private

  def self.extract_title_from_description(description)
    # Extract title from description (first line)
    description.split("\n").first&.strip || "Untitled Proposal"
  end

  def self.encode_propose_call(targets, values, calldatas, description)
    # This would use Web3 to encode the function call
    # For now, return placeholder data
    "0x" + "propose".unpack("H*").first
  end

  def self.encode_vote_call(proposal_id, support)
    # This would use Web3 to encode the vote function call
    "0x" + "vote".unpack("H*").first
  end

  def self.encode_execute_call(targets, values, calldatas, description)
    # This would use Web3 to encode the execute function call
    "0x" + "execute".unpack("H*").first
  end

  def self.sync_proposal_from_tally(tally_proposal)
    # Find or create proposal from Tally data
    proposal = Proposal.find_or_initialize_by(
      blockchain_id: tally_proposal['id']
    )

    proposal.assign_attributes(
      title: tally_proposal['title'],
      description: tally_proposal['description'],
      proposer_address: tally_proposal['proposer']['address'],
      status: map_tally_status(tally_proposal['status']),
      start_block: tally_proposal['startBlock'],
      end_block: tally_proposal['endBlock'],
      quorum: tally_proposal['quorum'],
      for_votes: tally_proposal.dig('proposalStats', 'forCount') || 0,
      against_votes: tally_proposal.dig('proposalStats', 'againstCount') || 0,
      abstain_votes: tally_proposal.dig('proposalStats', 'abstainCount') || 0
    )

    proposal.save!
    proposal
  end

  def self.map_tally_status(tally_status)
    case tally_status.downcase
    when 'active' then 'active'
    when 'succeeded' then 'succeeded'
    when 'defeated' then 'defeated'
    when 'executed' then 'executed'
    when 'canceled', 'cancelled' then 'cancelled'
    else 'pending'
    end
  end
end
```

## üìå Commit 85.3: Crear Models para Propuestas y Votos

üîπ **Mensaje de commit:**
```
feat(tally-governance): agrega modelos para propuestas y votos de gobernanza
```

**Generar migraciones:**
```bash
rails generate model Proposal title:string description:text proposer_address:string status:string blockchain_id:string targets:json values:json calldatas:json metadata_uri:string start_block:bigint end_block:bigint quorum:string for_votes:integer against_votes:integer abstain_votes:integer
rails generate model Vote proposal:references voter_address:string support:integer reason:text voting_power:string transaction_hash:string
```

**Crear** `app/models/proposal.rb`:
```ruby
class Proposal < ApplicationRecord
  has_many :votes, dependent: :destroy
  
  validates :title, presence: true
  validates :description, presence: true
  validates :proposer_address, presence: true, format: { with: /\A0x[a-fA-F0-9]{40}\z/ }
  validates :status, presence: true, inclusion: { 
    in: %w[pending active succeeded defeated executed cancelled] 
  }
  
  scope :active, -> { where(status: 'active') }
  scope :executable, -> { where(status: 'succeeded') }
  scope :recent, -> { order(created_at: :desc) }
  
  def active?
    status == 'active'
  end
  
  def succeeded?
    status == 'succeeded'
  end
  
  def executable?
    succeeded? && !executed?
  end
  
  def executed?
    status == 'executed'
  end
  
  def total_votes
    (for_votes || 0) + (against_votes || 0) + (abstain_votes || 0)
  end
  
  def vote_percentage(vote_type)
    return 0 if total_votes.zero?
    
    case vote_type
    when :for
      ((for_votes || 0).to_f / total_votes * 100).round(2)
    when :against
      ((against_votes || 0).to_f / total_votes * 100).round(2)
    when :abstain
      ((abstain_votes || 0).to_f / total_votes * 100).round(2)
    else
      0
    end
  end
  
  def user_vote(user_address)
    votes.find_by(voter_address: user_address&.downcase)
  end
  
  def has_voted?(user_address)
    user_vote(user_address).present?
  end
  
  def time_remaining
    return nil unless end_block && start_block
    
    current_block = Rails.cache.fetch('current_block_number', expires_in: 30.seconds) do
      # This would fetch from Web3 provider
      # For now, return a placeholder
      18_000_000
    end
    
    blocks_remaining = end_block - current_block
    return 0 if blocks_remaining <= 0
    
    # Assuming 12 second block time
    seconds_remaining = blocks_remaining * 12
    {
      blocks: blocks_remaining,
      seconds: seconds_remaining,
      hours: (seconds_remaining / 3600.0).round(1),
      days: (seconds_remaining / 86400.0).round(1)
    }
  end
  
  def short_description
    return description if description.length <= 200
    description[0..197] + "..."
  end
  
  def execution_calldata
    return nil unless targets.present? && values.present? && calldatas.present?
    
    {
      targets: targets,
      values: values,
      calldatas: calldatas,
      description_hash: Digest::SHA256.hexdigest(description)
    }
  end
end
```

**Crear** `app/models/vote.rb`:
```ruby
class Vote < ApplicationRecord
  belongs_to :proposal
  
  validates :voter_address, presence: true, format: { with: /\A0x[a-fA-F0-9]{40}\z/ }
  validates :support, presence: true, inclusion: { in: [0, 1, 2] } # 0=Against, 1=For, 2=Abstain
  validates :voting_power, presence: true
  
  scope :for_votes, -> { where(support: 1) }
  scope :against_votes, -> { where(support: 0) }
  scope :abstain_votes, -> { where(support: 2) }
  scope :recent, -> { order(created_at: :desc) }
  
  def support_text
    case support
    when 0 then 'Against'
    when 1 then 'For'
    when 2 then 'Abstain'
    else 'Unknown'
    end
  end
  
  def support_class
    case support
    when 0 then 'text-red-600'
    when 1 then 'text-green-600'
    when 2 then 'text-yellow-600'
    else 'text-gray-600'
    end
  end
  
  def voting_power_formatted
    return "0" unless voting_power.present?
    
    # Convert from wei to tokens (assuming 18 decimals)
    power = voting_power.to_i / 10**18
    
    if power >= 1_000_000
      "#{(power / 1_000_000.0).round(2)}M"
    elsif power >= 1_000
      "#{(power / 1_000.0).round(2)}K"
    else
      power.to_s
    end
  end
  
  def voter_short_address
    return voter_address unless voter_address.length > 10
    "#{voter_address[0..5]}...#{voter_address[-4..-1]}"
  end
end
```

**Ejecutar migraciones:**
```bash
rails db:migrate
```

## üìå Commit 85.4: Crear Controllers para Gobernanza

üîπ **Mensaje de commit:**
```
feat(tally-governance): agrega controllers para gesti√≥n de propuestas y votaci√≥n
```

**Crear** `app/controllers/governance_controller.rb`:
```ruby
class GovernanceController < ApplicationController
  before_action :authenticate_user!, except: [:index, :show]
  before_action :set_proposal, only: [:show, :vote, :execute]
  
  def index
    @proposals = Proposal.includes(:votes)
                         .recent
                         .page(params[:page])
                         .per(10)
    
    @stats = {
      total_proposals: Proposal.count,
      active_proposals: Proposal.active.count,
      executed_proposals: Proposal.where(status: 'executed').count,
      total_participants: Vote.distinct.count(:voter_address)
    }
  end
  
  def show
    @user_vote = current_user ? @proposal.user_vote(current_user.wallet_address) : nil
    @recent_votes = @proposal.votes.includes(:proposal).recent.limit(10)
    @voting_power = current_user ? get_user_voting_power(current_user.wallet_address) : "0"
  end
  
  def new
    @proposal = Proposal.new
  end
  
  def create
    unless current_user.wallet_address.present?
      return render json: { error: "Web3 wallet required to create proposals" }, status: :unauthorized
    end
    
    result = GovernanceService.create_proposal(
      current_user.wallet_address,
      proposal_params[:targets] || [],
      proposal_params[:values] || [],
      proposal_params[:calldatas] || [],
      proposal_params[:description],
      proposal_params[:metadata_uri]
    )
    
    if result[:success]
      render json: {
        message: "Proposal created successfully",
        proposal_id: result[:proposal_id],
        transaction_data: result[:transaction_data]
      }
    else
      render json: { error: result[:error] }, status: :unprocessable_entity
    end
  end
  
  def vote
    unless current_user.wallet_address.present?
      return render json: { error: "Web3 wallet required to vote" }, status: :unauthorized
    end
    
    result = GovernanceService.vote_on_proposal(
      current_user.wallet_address,
      @proposal.id,
      vote_params[:support].to_i,
      vote_params[:reason]
    )
    
    if result[:success]
      render json: {
        message: "Vote prepared successfully",
        vote_id: result[:vote_id],
        transaction_data: result[:transaction_data]
      }
    else
      render json: { error: result[:error] }, status: :unprocessable_entity
    end
  end
  
  def execute
    unless @proposal.executable?
      return render json: { error: "Proposal cannot be executed" }, status: :unprocessable_entity
    end
    
    result = GovernanceService.execute_proposal(@proposal.id)
    
    if result[:success]
      render json: {
        message: "Proposal execution prepared",
        transaction_data: result[:transaction_data]
      }
    else
      render json: { error: result[:error] }, status: :unprocessable_entity
    end
  end
  
  def delegate
    # Handle vote delegation
    unless current_user.wallet_address.present?
      return render json: { error: "Web3 wallet required for delegation" }, status: :unauthorized
    end
    
    delegate_address = delegation_params[:delegate_address]
    
    unless delegate_address.match?(/\A0x[a-fA-F0-9]{40}\z/)
      return render json: { error: "Invalid delegate address" }, status: :bad_request
    end
    
    render json: {
      message: "Delegation prepared",
      transaction_data: {
        to: GovernanceService::GOVERNANCE_TOKEN_ADDRESS,
        data: encode_delegate_call(delegate_address)
      }
    }
  end
  
  def voting_power
    address = params[:address] || current_user&.wallet_address
    
    unless address.present?
      return render json: { error: "Address required" }, status: :bad_request
    end
    
    power = get_user_voting_power(address)
    
    render json: {
      address: address,
      voting_power: power,
      formatted_power: format_voting_power(power)
    }
  end
  
  private
  
  def set_proposal
    @proposal = Proposal.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    render json: { error: "Proposal not found" }, status: :not_found
  end
  
  def proposal_params
    params.require(:proposal).permit(:title, :description, :metadata_uri, 
                                   targets: [], values: [], calldatas: [])
  end
  
  def vote_params
    params.require(:vote).permit(:support, :reason)
  end
  
  def delegation_params
    params.require(:delegation).permit(:delegate_address)
  end
  
  def get_user_voting_power(address)
    # This would integrate with Web3 to get actual voting power
    GovernanceService.get_voting_power(address)
  end
  
  def format_voting_power(power_wei)
    return "0" unless power_wei.present?
    
    power = power_wei.to_i / 10**18
    
    if power >= 1_000_000
      "#{(power / 1_000_000.0).round(2)}M GOVR"
    elsif power >= 1_000
      "#{(power / 1_000.0).round(2)}K GOVR"
    else
      "#{power} GOVR"
    end
  end
  
  def encode_delegate_call(delegate_address)
    # This would use Web3 to encode the delegate function call
    "0x" + "delegate".unpack("H*").first
  end
end
```

## üìå Commit 85.5: Crear UI para Gobernanza

üîπ **Mensaje de commit:**
```
feat(tally-governance): agrega interfaz de usuario para propuestas y votaci√≥n en Tally
```

**Crear** `app/views/governance/index.html.erb`:
```erb
<div class="min-h-screen bg-gray-50 py-8" data-controller="governance-dashboard">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    
    <!-- Header -->
    <div class="mb-8">
      <div class="flex items-center justify-between">
        <div>
          <h1 class="text-3xl font-bold text-gray-900 mb-2">
            DAO Governance
          </h1>
          <p class="text-gray-600">
            Participate in decentralized decision-making for the future of our platform
          </p>
        </div>
        
        <% if current_user %>
          <div class="flex gap-3">
            <button class="btn-secondary" data-action="click->governance-dashboard#checkVotingPower">
              Check Voting Power
            </button>
            <a href="<%= new_governance_path %>" class="btn-primary">
              Create Proposal
            </a>
          </div>
        <% else %>
          <a href="/auth/login" class="btn-primary">
            Connect Wallet to Participate
          </a>
        <% end %>
      </div>
    </div>

    <!-- Stats Overview -->
    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
      <div class="bg-white rounded-lg shadow p-6 text-center">
        <div class="text-2xl font-bold text-blue-600"><%= @stats[:total_proposals] %></div>
        <div class="text-sm text-gray-500">Total Proposals</div>
      </div>
      <div class="bg-white rounded-lg shadow p-6 text-center">
        <div class="text-2xl font-bold text-green-600"><%= @stats[:active_proposals] %></div>
        <div class="text-sm text-gray-500">Active Proposals</div>
      </div>
      <div class="bg-white rounded-lg shadow p-6 text-center">
        <div class="text-2xl font-bold text-purple-600"><%= @stats[:executed_proposals] %></div>
        <div class="text-sm text-gray-500">Executed Proposals</div>
      </div>
      <div class="bg-white rounded-lg shadow p-6 text-center">
        <div class="text-2xl font-bold text-yellow-600"><%= @stats[:total_participants] %></div>
        <div class="text-sm text-gray-500">Participants</div>
      </div>
    </div>

    <!-- Voting Power Display -->
    <% if current_user&.wallet_address %>
      <div id="voting-power-display" class="hidden mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <div class="flex items-center justify-between">
          <div>
            <h3 class="font-medium text-blue-900">Your Voting Power</h3>
            <p class="text-blue-700" data-governance-dashboard-target="votingPowerText">
              Loading...
            </p>
          </div>
          <button class="text-blue-600 hover:text-blue-500" 
                  data-action="click->governance-dashboard#hideVotingPower">
            ‚úï
          </button>
        </div>
      </div>
    <% end %>

    <!-- Proposals List -->
    <div class="space-y-6">
      <% @proposals.each do |proposal| %>
        <div class="bg-white shadow rounded-lg overflow-hidden">
          <div class="p-6">
            <div class="flex items-start justify-between">
              <div class="flex-1">
                <div class="flex items-center gap-3 mb-2">
                  <h3 class="text-lg font-semibold text-gray-900">
                    <%= link_to proposal.title, governance_path(proposal), 
                               class: "hover:text-blue-600" %>
                  </h3>
                  
                  <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium <%= proposal_status_class(proposal.status) %>">
                    <%= proposal.status.titleize %>
                  </span>
                </div>
                
                <p class="text-gray-600 mb-4">
                  <%= proposal.short_description %>
                </p>
                
                <div class="flex items-center gap-6 text-sm text-gray-500">
                  <div>
                    <span class="font-medium">Proposer:</span>
                    <%= proposal.proposer_address[0..9] %>...
                  </div>
                  
                  <div>
                    <span class="font-medium">Total Votes:</span>
                    <%= proposal.total_votes %>
                  </div>
                  
                  <% if proposal.time_remaining %>
                    <div>
                      <span class="font-medium">Time Remaining:</span>
                      <%= proposal.time_remaining[:days] %> days
                    </div>
                  <% end %>
                  
                  <div>
                    <span class="font-medium">Created:</span>
                    <%= time_ago_in_words(proposal.created_at) %> ago
                  </div>
                </div>
              </div>
              
              <div class="ml-6 flex-shrink-0">
                <% if proposal.active? && current_user&.wallet_address && !proposal.has_voted?(current_user.wallet_address) %>
                  <a href="<%= governance_path(proposal) %>" 
                     class="btn-primary">
                    Vote Now
                  </a>
                <% elsif proposal.executable? %>
                  <button class="btn-success"
                          data-action="click->governance-dashboard#executeProposal"
                          data-proposal-id="<%= proposal.id %>">
                    Execute
                  </button>
                <% else %>
                  <a href="<%= governance_path(proposal) %>" 
                     class="btn-secondary">
                    View Details
                  </a>
                <% end %>
              </div>
            </div>
            
            <!-- Vote Progress Bar -->
            <% if proposal.total_votes > 0 %>
              <div class="mt-4">
                <div class="flex justify-between text-sm text-gray-600 mb-1">
                  <span>For: <%= proposal.vote_percentage(:for) %>%</span>
                  <span>Against: <%= proposal.vote_percentage(:against) %>%</span>
                  <span>Abstain: <%= proposal.vote_percentage(:abstain) %>%</span>
                </div>
                
                <div class="w-full bg-gray-200 rounded-full h-2">
                  <div class="flex h-2 rounded-full overflow-hidden">
                    <div class="bg-green-500" style="width: <%= proposal.vote_percentage(:for) %>%"></div>
                    <div class="bg-red-500" style="width: <%= proposal.vote_percentage(:against) %>%"></div>
                    <div class="bg-yellow-500" style="width: <%= proposal.vote_percentage(:abstain) %>%"></div>
                  </div>
                </div>
              </div>
            <% end %>
          </div>
        </div>
      <% end %>
    </div>

    <!-- Pagination -->
    <div class="mt-8 flex justify-center">
      <%= paginate @proposals if respond_to?(:paginate) %>
    </div>

    <!-- Empty State -->
    <% if @proposals.empty? %>
      <div class="text-center py-12">
        <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
        </svg>
        <h3 class="mt-2 text-sm font-medium text-gray-900">No proposals yet</h3>
        <p class="mt-1 text-sm text-gray-500">Get started by creating the first proposal.</p>
        <div class="mt-6">
          <a href="<%= new_governance_path %>" class="btn-primary">
            Create First Proposal
          </a>
        </div>
      </div>
    <% end %>
  </div>
</div>
```

## üìå Commit 85.6: Crear Stimulus Controllers para Interactividad

üîπ **Mensaje de commit:**
```
feat(tally-governance): agrega controladores Stimulus para interacci√≥n con blockchain
```

**Crear** `app/javascript/controllers/governance_dashboard_controller.js`:
```javascript
import { Controller } from "@hotwired/stimulus";
import Web3 from "web3";

export default class extends Controller {
  static targets = ["votingPowerText"];

  connect() {
    this.web3 = null;
    this.currentAccount = null;
  }

  async checkVotingPower() {
    try {
      await this.initWeb3();
      
      const response = await fetch(`/governance/voting_power?address=${this.currentAccount}`, {
        headers: {
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      });
      
      const data = await response.json();
      
      if (response.ok) {
        this.votingPowerTextTarget.textContent = data.formatted_power;
        document.getElementById('voting-power-display').classList.remove('hidden');
      } else {
        this.showError(data.error || 'Failed to fetch voting power');
      }
    } catch (error) {
      console.error('Error checking voting power:', error);
      this.showError('Failed to check voting power');
    }
  }

  hideVotingPower() {
    document.getElementById('voting-power-display').classList.add('hidden');
  }

  async executeProposal(event) {
    const proposalId = event.target.dataset.proposalId;
    
    if (!confirm('Are you sure you want to execute this proposal?')) {
      return;
    }

    try {
      await this.initWeb3();
      
      const response = await fetch(`/governance/${proposalId}/execute`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        }
      });
      
      const data = await response.json();
      
      if (response.ok) {
        await this.sendTransaction(data.transaction_data);
        this.showSuccess('Proposal execution initiated! Check your wallet.');
      } else {
        this.showError(data.error || 'Failed to execute proposal');
      }
    } catch (error) {
      console.error('Error executing proposal:', error);
      this.showError('Failed to execute proposal');
    }
  }

  async initWeb3() {
    if (!window.ethereum) {
      throw new Error('MetaMask not found');
    }

    this.web3 = new Web3(window.ethereum);
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    this.currentAccount = accounts[0];
  }

  async sendTransaction(transactionData) {
    const txParams = {
      from: this.currentAccount,
      to: transactionData.to,
      data: transactionData.data,
      gas: '0x76c0', // 30400 gas limit
    };

    const txHash = await window.ethereum.request({
      method: 'eth_sendTransaction',
      params: [txParams],
    });

    console.log('Transaction sent:', txHash);
    return txHash;
  }

  showSuccess(message) {
    this.showToast(message, 'success');
  }

  showError(message) {
    this.showToast(message, 'error');
  }

  showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-x-full ${this.getToastClasses(type)}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.remove('translate-x-full'), 10);
    
    setTimeout(() => {
      toast.classList.add('translate-x-full');
      setTimeout(() => document.body.removeChild(toast), 300);
    }, 5000);
  }

  getToastClasses(type) {
    switch (type) {
      case 'success':
        return 'bg-green-500 text-white';
      case 'error':
        return 'bg-red-500 text-white';
      case 'info':
      default:
        return 'bg-blue-500 text-white';
    }
  }
}
```

**Crear** `app/javascript/controllers/proposal_voting_controller.js`:
```javascript
import { Controller } from "@hotwired/stimulus";
import Web3 from "web3";

export default class extends Controller {
  static targets = ["voteButtons", "reasonTextarea"];
  static values = { proposalId: Number };

  connect() {
    this.web3 = null;
    this.currentAccount = null;
    this.selectedVote = null;
  }

  selectVote(event) {
    const support = parseInt(event.target.dataset.support);
    this.selectedVote = support;
    
    // Update button states
    this.voteButtonsTarget.querySelectorAll('button').forEach(btn => {
      btn.classList.remove('ring-2', 'ring-blue-500', 'bg-blue-50');
    });
    
    event.target.classList.add('ring-2', 'ring-blue-500', 'bg-blue-50');
    
    // Enable submit button
    const submitButton = this.element.querySelector('[data-action*="submitVote"]');
    if (submitButton) {
      submitButton.disabled = false;
      submitButton.classList.remove('opacity-50');
    }
  }

  async submitVote() {
    if (this.selectedVote === null) {
      this.showError('Please select a vote option');
      return;
    }

    try {
      await this.initWeb3();
      
      const reason = this.reasonTextareaTarget.value;
      
      const response = await fetch(`/governance/${this.proposalIdValue}/vote`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({
          vote: {
            support: this.selectedVote,
            reason: reason
          }
        })
      });
      
      const data = await response.json();
      
      if (response.ok) {
        await this.sendTransaction(data.transaction_data);
        this.showSuccess('Vote submitted! Check your wallet for confirmation.');
        
        // Disable voting interface
        this.disableVoting();
      } else {
        this.showError(data.error || 'Failed to submit vote');
      }
    } catch (error) {
      console.error('Error submitting vote:', error);
      this.showError('Failed to submit vote');
    }
  }

  async initWeb3() {
    if (!window.ethereum) {
      throw new Error('MetaMask not found');
    }

    this.web3 = new Web3(window.ethereum);
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    this.currentAccount = accounts[0];
  }

  async sendTransaction(transactionData) {
    const txParams = {
      from: this.currentAccount,
      to: transactionData.to,
      data: transactionData.data,
      gas: '0x76c0', // 30400 gas limit
    };

    const txHash = await window.ethereum.request({
      method: 'eth_sendTransaction',
      params: [txParams],
    });

    console.log('Vote transaction sent:', txHash);
    return txHash;
  }

  disableVoting() {
    // Disable all vote buttons
    this.voteButtonsTarget.querySelectorAll('button').forEach(btn => {
      btn.disabled = true;
      btn.classList.add('opacity-50');
    });
    
    // Disable reason textarea
    this.reasonTextareaTarget.disabled = true;
    
    // Show voted message
    const votingContainer = this.element.querySelector('.voting-container');
    if (votingContainer) {
      votingContainer.innerHTML = `
        <div class="text-center py-8">
          <div class="text-green-600 text-4xl mb-4">‚úì</div>
          <h3 class="text-lg font-medium text-gray-900 mb-2">Vote Submitted</h3>
          <p class="text-gray-600">Your vote has been recorded on the blockchain.</p>
        </div>
      `;
    }
  }

  showSuccess(message) {
    this.showToast(message, 'success');
  }

  showError(message) {
    this.showToast(message, 'error');
  }

  showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-x-full ${this.getToastClasses(type)}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.remove('translate-x-full'), 10);
    
    setTimeout(() => {
      toast.classList.add('translate-x-full');
      setTimeout(() => document.body.removeChild(toast), 300);
    }, 5000);
  }

  getToastClasses(type) {
    switch (type) {
      case 'success':
        return 'bg-green-500 text-white';
      case 'error':
        return 'bg-red-500 text-white';
      case 'info':
      default:
        return 'bg-blue-500 text-white';
    }
  }
}
```

## üìù Configuraci√≥n y Testing

### Configurar credenciales en Rails

```bash
rails credentials:edit
```

```yaml
tally:
  api_key: your_tally_api_key
  dao_slug: your_dao_slug

governance:
  governor_address: "0xYourGovernorContractAddress"
  token_address: "0xYourTokenContractAddress"
  timelock_address: "0xYourTimelockAddress"

ethereum:
  rpc_url: "https://mainnet.infura.io/v3/your_project_id"
```

### Agregar rutas

```ruby
# config/routes.rb
Rails.application.routes.draw do
  resources :governance, only: [:index, :show, :new, :create] do
    member do
      post :vote
      post :execute
    end
    
    collection do
      post :delegate
      get :voting_power
    end
  end
end
```

### Ejemplo de Deploy en Hardhat

```bash
# Compilar contratos
npx hardhat compile

# Deploy en testnet
npx hardhat run scripts/deploy-governance.js --network goerli

# Verificar contratos en Etherscan
npx hardhat verify --network goerli DEPLOYED_ADDRESS
```

### Testing de Propuestas

```bash
# Crear propuesta
curl -X POST "http://localhost:3000/governance" \
  -H "Content-Type: application/json" \
  -d '{
    "proposal": {
      "title": "Increase Treasury Allocation",
      "description": "Proposal to increase treasury allocation by 10%",
      "targets": ["0xTreasuryAddress"],
      "values": ["0"],
      "calldatas": ["0x"]
    }
  }'

# Votar en propuesta
curl -X POST "http://localhost:3000/governance/1/vote" \
  -H "Content-Type: application/json" \
  -d '{
    "vote": {
      "support": 1,
      "reason": "This will help fund development"
    }
  }'
```

## üéØ Ventajas de la Implementaci√≥n

1. **üó≥Ô∏è Gobernanza Transparente**: Todas las decisiones son p√∫blicas y auditables
2. **‚ö° Ejecuci√≥n Autom√°tica**: Las propuestas aprobadas se ejecutan autom√°ticamente
3. **üõ°Ô∏è Seguridad Robusta**: Timelock y emergencia de cancelaci√≥n
4. **üìä Integraci√≥n con Tally**: Dashboard profesional para gobernanza
5. **üîó Interoperabilidad**: Compatible con herramientas est√°ndar de DAO
6. **üéØ UX Optimizada**: Interfaz intuitiva para participaci√≥n masiva

Esta implementaci√≥n proporciona un sistema completo de gobernanza on-chain que permite a la DAO tomar decisiones de manera descentralizada y ejecutar cambios autom√°ticamente en la blockchain, integr√°ndose perfectamente con Tally para una experiencia de usuario profesional.