# ✅ Paso 60: Implementar Refresh Tokens para Sesiones Largas en Rodauth + JWT

Implementaremos un sistema completo de Refresh Tokens integrado con Rodauth y JWT, permitiendo sesiones de larga duración seguras con renovación automática y revocación granular.

## 🎯 Tecnologías Integradas

✅ **Rodauth JWT Refresh Token Support** → Permite mantener sesiones activas sin volver a firmar  
✅ **Expiración y Revocación de Tokens** → Control total sobre la seguridad y ciclo de vida  
✅ **Almacenamiento Seguro** → Tokens seguros y revocables con rotación automática  
✅ **Protección contra Reutilización** → Previene ataques de replay en Refresh Tokens  
✅ **Web3 Integration** → Compatible con autenticación blockchain y Smart Contract Wallets  
✅ **Device Management** → Rastreo y gestión de dispositivos y sesiones activas  

## 📌 Commit 60.1: Configurar Rodauth para Soporte de Refresh Tokens

🔹 **Mensaje de commit:**
```
feat(auth-refresh): agrega soporte completo para Refresh Tokens en Rodauth con JWT
```

🔹 **Contenido del commit:**

**Instalar gems adicionales:**
```bash
bundle add jwt redis-rails
```

**Modificar** `app/misc/rodauth_main.rb`:
```ruby
class RodauthMain < Rodauth::Auth
  configure do
    # Enable JWT and refresh token features
    enable :login, :logout, :create_account, :verify_account, :reset_password,
           :change_password, :change_login, :remember, :lockout,
           :otp, :sms_codes, :recovery_codes, :webauthn,
           :two_factor_base, :two_factor_manage,
           :jwt, :jwt_refresh, :active_sessions

    # Database configuration
    db DB
    accounts_table :users
    
    # JWT Configuration
    jwt_secret Rails.application.credentials.secret_key_base
    jwt_access_token_period 60 * 15 # 15 minutes
    jwt_refresh_token_period 60 * 60 * 24 * 30 # 30 days
    
    # Refresh Token Configuration
    jwt_refresh_token_table :refresh_tokens
    jwt_refresh_reuse "rotate" # Rotate refresh tokens on each use
    jwt_refresh_token_deadline_interval 60 * 60 * 24 * 30 # 30 days
    
    # Device tracking for sessions
    active_sessions_table :active_sessions
    active_sessions_account_id_column :user_id
    
    # Security settings for JWT
    jwt_authorization_ignore %w[/auth/refresh /auth/web3_nonce /health]
    jwt_authorization_remove 'Bearer '
    
    # Custom JWT claims
    jwt_payload do
      {
        sub: account_id.to_s,
        email: account[:email],
        wallet_address: account[:wallet_address],
        wallet_type: account[:wallet_type],
        mfa_enabled: two_factor_authentication_setup?,
        exp: Time.now.to_i + jwt_access_token_period,
        iat: Time.now.to_i,
        jti: SecureRandom.uuid, # Unique token ID for revocation
        device_id: session[:device_id] || generate_device_id
      }
    end

    # Refresh token payload with device tracking
    jwt_refresh_payload do
      {
        sub: account_id.to_s,
        type: 'refresh',
        device_id: session[:device_id] || generate_device_id,
        device_name: request.user_agent&.truncate(100),
        ip_address: request.ip,
        created_at: Time.now.to_i,
        exp: Time.now.to_i + jwt_refresh_token_deadline_interval,
        jti: SecureRandom.uuid
      }
    end

    # Token validation and security
    before_jwt_response do
      response.headers['Access-Control-Allow-Origin'] = '*'
      response.headers['Access-Control-Allow-Methods'] = 'POST, GET, OPTIONS, DELETE, PUT, PATCH'
      response.headers['Access-Control-Allow-Headers'] = 'Authorization, Content-Type'
    end

    # Store refresh token metadata
    after_jwt_refresh_token_create do
      store_refresh_token_metadata
    end

    # Cleanup old tokens
    after_jwt_refresh_token_use do
      cleanup_expired_tokens
    end

    # Revoke all tokens on logout
    after_logout do
      revoke_all_user_tokens
    end

    # Custom methods for enhanced functionality
    auth_class_eval do
      def generate_device_id
        device_id = SecureRandom.uuid
        session[:device_id] = device_id
        device_id
      end

      def store_refresh_token_metadata
        return unless jwt_refresh_token

        # Store additional metadata in Redis for fast lookup
        device_id = jwt_refresh_payload_hash[:device_id]
        
        redis_key = "refresh_token:#{account_id}:#{device_id}"
        metadata = {
          user_id: account_id,
          device_id: device_id,
          device_name: jwt_refresh_payload_hash[:device_name],
          ip_address: jwt_refresh_payload_hash[:ip_address],
          created_at: Time.now.iso8601,
          last_used_at: Time.now.iso8601,
          user_agent: request.user_agent,
          location: detect_location_from_ip(request.ip)
        }
        
        Rails.cache.write(redis_key, metadata.to_json, expires_in: jwt_refresh_token_deadline_interval)
      end

      def cleanup_expired_tokens
        # Clean up expired refresh tokens from database
        jwt_refresh_token_ds.where(Sequel.lit('deadline < ?', Time.now)).delete
        
        # Clean up expired active sessions
        active_sessions_ds.where(Sequel.lit('last_use < ?', 30.days.ago)).delete
      end

      def revoke_all_user_tokens
        # Revoke all refresh tokens for user
        jwt_refresh_token_ds.where(account_id: account_id).delete
        
        # Clear all Redis cache entries
        pattern = "refresh_token:#{account_id}:*"
        Rails.cache.delete_matched(pattern)
        
        # Remove active sessions
        active_sessions_ds.where(account_id: account_id).delete
      end

      def revoke_device_tokens(device_id)
        # Revoke tokens for specific device
        jwt_refresh_token_ds.where(
          account_id: account_id,
          device_id: device_id
        ).delete
        
        # Clear device cache
        redis_key = "refresh_token:#{account_id}:#{device_id}"
        Rails.cache.delete(redis_key)
      end

      def detect_location_from_ip(ip)
        # Basic IP geolocation (you can integrate with MaxMind or similar)
        return 'localhost' if ip == '127.0.0.1' || ip == '::1'
        return 'private' if ip.match?(/^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.)/)
        
        # For production, integrate with a geolocation service
        'unknown'
      end

      def current_device_sessions
        # Get all active sessions for current user
        pattern = "refresh_token:#{account_id}:*"
        cache_keys = Rails.cache.send(:cache).keys(pattern) rescue []
        
        cache_keys.map do |key|
          metadata = Rails.cache.read(key)
          JSON.parse(metadata) if metadata
        end.compact
      end

      # Web3 specific refresh token handling
      def create_web3_jwt_refresh_token
        # Enhanced refresh token for Web3 users
        payload = jwt_refresh_payload_hash.merge(
          wallet_address: account[:wallet_address],
          wallet_type: account[:wallet_type],
          supports_web3: true
        )
        
        JWT.encode(payload, jwt_secret, 'HS256')
      end

      def validate_web3_refresh_token(token)
        begin
          payload = JWT.decode(token, jwt_secret, true, { algorithm: 'HS256' })[0]
          
          # Verify token hasn't been revoked
          return false unless jwt_refresh_token_ds.where(
            account_id: payload['sub'],
            token: token
          ).first
          
          # Additional Web3 validation if needed
          if payload['wallet_address'] && account[:wallet_address]
            return payload['wallet_address'] == account[:wallet_address]
          end
          
          true
        rescue JWT::DecodeError
          false
        end
      end
    end

    # Routes configuration
    prefix '/auth'
    jwt_refresh_route 'refresh'
    
    # Redirect configuration for JWT mode
    login_redirect { '/auth/success' }
    logout_redirect { '/auth/logout-success' }
  end
end
```

## 📌 Commit 60.2: Crear Migraciones para Refresh Tokens

🔹 **Mensaje de commit:**
```
feat(auth-refresh): agrega migraciones para almacenar Refresh Tokens y sesiones activas
```

**Generar migraciones:**
```bash
rails generate migration CreateRefreshTokens
rails generate migration CreateActiveSessions
rails generate migration AddDeviceTrackingToUsers
```

**Crear** `db/migrate/[timestamp]_create_refresh_tokens.rb`:
```ruby
class CreateRefreshTokens < ActiveRecord::Migration[7.0]
  def change
    create_table :refresh_tokens do |t|
      t.references :account, null: false, foreign_key: { to_table: :users }
      t.text :token, null: false
      t.string :device_id, null: false
      t.string :device_name, limit: 200
      t.string :ip_address
      t.string :user_agent, limit: 500
      t.string :location, limit: 100
      t.datetime :deadline, null: false
      t.datetime :last_used_at
      t.timestamps
    end
    
    add_index :refresh_tokens, :token, unique: true
    add_index :refresh_tokens, :device_id
    add_index :refresh_tokens, :deadline
    add_index :refresh_tokens, [:account_id, :device_id], name: 'index_refresh_tokens_on_account_device'
  end
end
```

**Crear** `db/migrate/[timestamp]_create_active_sessions.rb`:
```ruby
class CreateActiveSessions < ActiveRecord::Migration[7.0]
  def change
    create_table :active_sessions do |t|
      t.references :user, null: false, foreign_key: true
      t.string :session_id, null: false
      t.string :device_id, null: false
      t.string :device_name, limit: 200
      t.string :ip_address
      t.string :user_agent, limit: 500
      t.string :location, limit: 100
      t.datetime :last_use, null: false
      t.timestamps
    end
    
    add_index :active_sessions, :session_id, unique: true
    add_index :active_sessions, :device_id
    add_index :active_sessions, :last_use
    add_index :active_sessions, [:user_id, :device_id], name: 'index_active_sessions_on_user_device'
  end
end
```

**Crear** `db/migrate/[timestamp]_add_device_tracking_to_users.rb`:
```ruby
class AddDeviceTrackingToUsers < ActiveRecord::Migration[7.0]
  def change
    add_column :users, :max_concurrent_sessions, :integer, default: 5
    add_column :users, :last_jwt_refresh_at, :datetime
    add_column :users, :jwt_refresh_count, :integer, default: 0
    
    add_index :users, :last_jwt_refresh_at
  end
end
```

**Ejecutar migraciones:**
```bash
rails db:migrate
```

## 📌 Commit 60.3: Crear API Controllers para Gestión de Tokens

🔹 **Mensaje de commit:**
```
feat(auth-refresh): agrega API controllers para gestión avanzada de JWT y Refresh Tokens
```

**Crear** `app/controllers/api/auth_controller.rb`:
```ruby
class Api::AuthController < ApplicationController
  skip_before_action :verify_authenticity_token
  before_action :authenticate_jwt, except: [:login, :refresh, :web3_nonce, :web3_login]
  
  def login
    # Traditional email/password login
    rodauth = RodauthMain.allocate
    rodauth.instance_variable_set(:@scope, self)
    
    if rodauth.login_form_valid? && rodauth.authenticate_login_password(params[:password])
      tokens = generate_token_pair(rodauth.account)
      
      render json: {
        message: "Login successful",
        user: format_user_data(rodauth.account),
        access_token: tokens[:access_token],
        refresh_token: tokens[:refresh_token],
        expires_in: rodauth.jwt_access_token_period
      }
    else
      render json: { error: "Invalid credentials" }, status: :unauthorized
    end
  end

  def web3_login
    # Web3 wallet authentication
    wallet_address = params[:wallet_address]&.downcase
    signature = params[:signature]
    nonce = params[:nonce]
    
    unless valid_web3_credentials?(wallet_address, signature, nonce)
      return render json: { error: "Invalid Web3 credentials" }, status: :unauthorized
    end

    # Find or create user
    user = User.find_by(wallet_address: wallet_address) ||
           create_web3_user(wallet_address)

    rodauth = RodauthMain.allocate
    rodauth.instance_variable_set(:@scope, self)
    rodauth.instance_variable_set(:@account, user.attributes.symbolize_keys)

    tokens = generate_token_pair(user.attributes.symbolize_keys)
    
    render json: {
      message: "Web3 authentication successful",
      user: format_user_data(user.attributes.symbolize_keys),
      access_token: tokens[:access_token],
      refresh_token: tokens[:refresh_token],
      expires_in: rodauth.jwt_access_token_period
    }
  end

  def refresh
    refresh_token = params[:refresh_token] || 
                   request.headers['Authorization']&.gsub(/^Bearer /, '')
    
    unless refresh_token
      return render json: { error: "Refresh token required" }, status: :bad_request
    end

    # Validate and decode refresh token
    begin
      payload = JWT.decode(refresh_token, jwt_secret, true, { algorithm: 'HS256' })[0]
    rescue JWT::DecodeError => e
      return render json: { error: "Invalid refresh token: #{e.message}" }, status: :unauthorized
    end

    # Check if token exists in database and hasn't been revoked
    stored_token = DB[:refresh_tokens].where(
      account_id: payload['sub'],
      token: refresh_token
    ).first

    unless stored_token
      return render json: { error: "Refresh token revoked or not found" }, status: :unauthorized
    end

    # Check if token is expired
    if Time.now > Time.at(payload['exp'])
      DB[:refresh_tokens].where(id: stored_token[:id]).delete
      return render json: { error: "Refresh token expired" }, status: :unauthorized
    end

    # Get user account
    user = User.find(payload['sub'])
    unless user
      return render json: { error: "User not found" }, status: :unauthorized
    end

    # Revoke old refresh token (token rotation)
    DB[:refresh_tokens].where(id: stored_token[:id]).delete
    
    # Update last used timestamp
    user.update(last_jwt_refresh_at: Time.current, jwt_refresh_count: user.jwt_refresh_count + 1)

    # Generate new token pair
    rodauth = RodauthMain.allocate
    rodauth.instance_variable_set(:@scope, self)
    rodauth.instance_variable_set(:@account, user.attributes.symbolize_keys)

    tokens = generate_token_pair(user.attributes.symbolize_keys)
    
    render json: {
      message: "Tokens refreshed successfully",
      access_token: tokens[:access_token],
      refresh_token: tokens[:refresh_token],
      expires_in: rodauth.jwt_access_token_period
    }
  end

  def logout
    refresh_token = params[:refresh_token]
    device_id = params[:device_id]
    
    if refresh_token
      # Revoke specific refresh token
      begin
        payload = JWT.decode(refresh_token, jwt_secret, true, { algorithm: 'HS256' })[0]
        DB[:refresh_tokens].where(
          account_id: payload['sub'],
          token: refresh_token
        ).delete
      rescue JWT::DecodeError
        # Token already invalid, continue with logout
      end
    end

    if device_id && current_user
      # Revoke all tokens for specific device
      DB[:refresh_tokens].where(
        account_id: current_user.id,
        device_id: device_id
      ).delete
      
      # Clear device cache
      Rails.cache.delete("refresh_token:#{current_user.id}:#{device_id}")
    end

    render json: { message: "Logout successful" }
  end

  def logout_all
    # Revoke all refresh tokens for user
    DB[:refresh_tokens].where(account_id: current_user.id).delete
    
    # Clear all device cache entries
    pattern = "refresh_token:#{current_user.id}:*"
    Rails.cache.delete_matched(pattern)
    
    # Remove all active sessions
    DB[:active_sessions].where(user_id: current_user.id).delete
    
    render json: { message: "All sessions logged out successfully" }
  end

  def sessions
    # Get all active sessions for current user
    sessions = current_user_sessions
    
    render json: {
      sessions: sessions,
      current_device_id: session[:device_id]
    }
  end

  def revoke_session
    device_id = params[:device_id]
    
    unless device_id
      return render json: { error: "Device ID required" }, status: :bad_request
    end

    # Revoke tokens for specific device
    deleted_count = DB[:refresh_tokens].where(
      account_id: current_user.id,
      device_id: device_id
    ).delete
    
    # Clear device cache
    Rails.cache.delete("refresh_token:#{current_user.id}:#{device_id}")
    
    if deleted_count > 0
      render json: { message: "Session revoked successfully" }
    else
      render json: { error: "Session not found" }, status: :not_found
    end
  end

  private

  def authenticate_jwt
    token = request.headers['Authorization']&.gsub(/^Bearer /, '')
    
    unless token
      return render json: { error: "Access token required" }, status: :unauthorized
    end

    begin
      payload = JWT.decode(token, jwt_secret, true, { algorithm: 'HS256' })[0]
      @current_user = User.find(payload['sub'])
    rescue JWT::DecodeError => e
      render json: { error: "Invalid access token: #{e.message}" }, status: :unauthorized
    rescue ActiveRecord::RecordNotFound
      render json: { error: "User not found" }, status: :unauthorized
    end
  end

  def current_user
    @current_user
  end

  def generate_token_pair(account)
    rodauth = RodauthMain.allocate
    rodauth.instance_variable_set(:@scope, self)
    rodauth.instance_variable_set(:@account, account)
    
    # Generate access token
    access_token = rodauth.create_jwt
    
    # Generate refresh token
    refresh_token = rodauth.create_jwt_refresh_token
    
    # Store refresh token in database
    store_refresh_token(account[:id], refresh_token)
    
    {
      access_token: access_token,
      refresh_token: refresh_token
    }
  end

  def store_refresh_token(account_id, token)
    begin
      payload = JWT.decode(token, jwt_secret, false)[0]
      
      DB[:refresh_tokens].insert(
        account_id: account_id,
        token: token,
        device_id: payload['device_id'],
        device_name: payload['device_name'],
        ip_address: payload['ip_address'],
        user_agent: request.user_agent,
        location: detect_location_from_ip(request.ip),
        deadline: Time.at(payload['exp']),
        last_used_at: Time.current,
        created_at: Time.current,
        updated_at: Time.current
      )
    rescue => e
      Rails.logger.error "Failed to store refresh token: #{e.message}"
    end
  end

  def valid_web3_credentials?(wallet_address, signature, nonce)
    return false unless wallet_address && signature && nonce
    
    # Verify nonce is valid and not expired
    cached_nonce = Rails.cache.read("web3_nonce_#{nonce}")
    return false unless cached_nonce
    
    message = "Welcome to #{Rails.application.class.module_parent_name}.\n\nNonce: #{nonce}\nTimestamp: #{cached_nonce[:timestamp]}"
    
    # Try EOA verification first
    begin
      signer_address = Ethereum::Message.verify_signature(message, signature)
      return true if signer_address.downcase == wallet_address
    rescue
      # Continue to Smart Contract Wallet verification
    end
    
    # Try Smart Contract Wallet verification
    SmartContractWalletService.verify_signature(wallet_address, message, signature)
  end

  def create_web3_user(wallet_address)
    User.create!(
      email: "#{wallet_address}@web3.local",
      wallet_address: wallet_address,
      wallet_type: detect_wallet_type(wallet_address),
      password_digest: BCrypt::Password.create(SecureRandom.hex(32)) # Random password for security
    )
  end

  def detect_wallet_type(wallet_address)
    # Simple detection - enhance with actual Web3 calls in production
    'eoa' # Default to EOA
  end

  def detect_location_from_ip(ip)
    return 'localhost' if ['127.0.0.1', '::1'].include?(ip)
    return 'private' if ip.match?(/^(10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.)/)
    'unknown'
  end

  def format_user_data(account)
    {
      id: account[:id],
      email: account[:email],
      wallet_address: account[:wallet_address],
      wallet_type: account[:wallet_type],
      mfa_enabled: account[:otp_key].present? || account[:sms_phone].present?
    }
  end

  def current_user_sessions
    # Get active refresh tokens for user
    tokens = DB[:refresh_tokens].where(account_id: current_user.id).all
    
    tokens.map do |token|
      {
        device_id: token[:device_id],
        device_name: token[:device_name],
        ip_address: token[:ip_address],
        location: token[:location],
        last_used_at: token[:last_used_at],
        created_at: token[:created_at],
        is_current: token[:device_id] == session[:device_id]
      }
    end
  end

  def jwt_secret
    Rails.application.credentials.secret_key_base
  end
end
```

## 📌 Commit 60.4: Crear UI para Gestión de Sesiones

🔹 **Mensaje de commit:**
```
feat(auth-refresh): agrega UI para gestión de dispositivos y sesiones activas
```

**Crear** `app/views/auth/sessions.html.erb`:
```erb
<div class="min-h-screen bg-gray-50 py-12">
  <div class="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8">
    
    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-3xl font-bold text-gray-900 mb-2">
        Active Sessions
      </h1>
      <p class="text-gray-600">
        Manage your logged-in devices and sessions
      </p>
    </div>

    <!-- Session Management -->
    <div class="bg-white shadow rounded-lg" data-controller="session-manager">
      <div class="p-6">
        
        <!-- Current Session Info -->
        <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
          <div class="flex items-center justify-between">
            <div>
              <h3 class="font-medium text-blue-900">Current Session</h3>
              <p class="text-sm text-blue-700 mt-1">
                Device: <span data-session-manager-target="currentDevice">Loading...</span>
              </p>
              <p class="text-sm text-blue-600">
                IP: <span data-session-manager-target="currentIp">Loading...</span>
              </p>
            </div>
            <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
              ✓ Active
            </span>
          </div>
        </div>

        <!-- Sessions List -->
        <div class="space-y-4" data-session-manager-target="sessionsList">
          <!-- Sessions will be loaded here -->
        </div>

        <!-- Actions -->
        <div class="mt-6 pt-6 border-t border-gray-200">
          <div class="flex flex-col sm:flex-row gap-3">
            <button type="button"
                    class="btn-secondary flex items-center justify-center"
                    data-action="click->session-manager#refreshSessions">
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
              </svg>
              Refresh Sessions
            </button>
            
            <button type="button"
                    class="btn-danger flex items-center justify-center"
                    data-action="click->session-manager#logoutAllOther"
                    data-session-manager-target="logoutAllButton">
              <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"/>
              </svg>
              End All Other Sessions
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Security Notice -->
    <div class="mt-8 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
      <div class="flex">
        <div class="flex-shrink-0">
          <svg class="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
          </svg>
        </div>
        <div class="ml-3">
          <h3 class="text-sm font-medium text-yellow-800">Session Security</h3>
          <div class="mt-2 text-sm text-yellow-700">
            <ul class="list-disc list-inside space-y-1">
              <li>Review your active sessions regularly</li>
              <li>End sessions from unfamiliar devices or locations</li>
              <li>Use "End All Other Sessions" if you suspect unauthorized access</li>
              <li>Enable two-factor authentication for additional security</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <!-- Back to Account -->
    <div class="mt-8 text-center">
      <a href="/account" class="text-blue-600 hover:text-blue-500 text-sm">
        ← Back to Account Settings
      </a>
    </div>
  </div>
</div>
```

## 📌 Commit 60.5: Crear Stimulus Controller para Gestión de Sesiones

🔹 **Mensaje de commit:**
```
feat(auth-refresh): agrega controlador Stimulus para gestión interactiva de sesiones
```

**Crear** `app/javascript/controllers/session_manager_controller.js`:
```javascript
import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  static targets = ["sessionsList", "currentDevice", "currentIp", "logoutAllButton"];

  connect() {
    this.loadSessions();
    this.detectCurrentDevice();
  }

  async loadSessions() {
    try {
      const response = await this.makeAuthenticatedRequest('/api/auth/sessions');
      const data = await response.json();
      
      if (response.ok) {
        this.renderSessions(data.sessions, data.current_device_id);
      } else {
        this.showError(data.error || 'Failed to load sessions');
      }
    } catch (error) {
      console.error('Error loading sessions:', error);
      this.showError('Failed to load sessions');
    }
  }

  renderSessions(sessions, currentDeviceId) {
    const otherSessions = sessions.filter(session => session.device_id !== currentDeviceId);
    
    if (otherSessions.length === 0) {
      this.sessionsListTarget.innerHTML = `
        <div class="text-center py-8">
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
          <h3 class="mt-2 text-sm font-medium text-gray-900">No other active sessions</h3>
          <p class="mt-1 text-sm text-gray-500">You're only logged in on this device.</p>
        </div>
      `;
      this.logoutAllButtonTarget.disabled = true;
      this.logoutAllButtonTarget.classList.add('opacity-50');
      return;
    }

    const sessionsHtml = otherSessions.map(session => this.renderSession(session)).join('');
    this.sessionsListTarget.innerHTML = sessionsHtml;
    
    this.logoutAllButtonTarget.disabled = false;
    this.logoutAllButtonTarget.classList.remove('opacity-50');
  }

  renderSession(session) {
    const deviceIcon = this.getDeviceIcon(session.device_name);
    const timeAgo = this.timeAgo(new Date(session.last_used_at));
    const location = session.location !== 'unknown' ? session.location : 'Unknown location';

    return `
      <div class="flex items-center justify-between p-4 border border-gray-200 rounded-lg">
        <div class="flex items-center space-x-3">
          <div class="flex-shrink-0">
            ${deviceIcon}
          </div>
          <div>
            <h4 class="text-sm font-medium text-gray-900">${session.device_name || 'Unknown Device'}</h4>
            <p class="text-sm text-gray-500">
              ${session.ip_address} • ${location}
            </p>
            <p class="text-xs text-gray-400">
              Last active: ${timeAgo}
            </p>
          </div>
        </div>
        
        <button type="button"
                class="text-sm text-red-600 hover:text-red-700 font-medium"
                data-action="click->session-manager#revokeSession"
                data-device-id="${session.device_id}">
          End Session
        </button>
      </div>
    `;
  }

  getDeviceIcon(deviceName) {
    const name = (deviceName || '').toLowerCase();
    
    if (name.includes('mobile') || name.includes('android') || name.includes('iphone')) {
      return `
        <svg class="h-6 w-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a1 1 0 001-1V4a1 1 0 00-1-1H8a1 1 0 00-1 1v16a1 1 0 001 1z"/>
        </svg>
      `;
    } else if (name.includes('tablet') || name.includes('ipad')) {
      return `
        <svg class="h-6 w-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17V7m0 10a2 2 0 01-2 2H5a2 2 0 01-2-2V7a2 2 0 012-2h2a2 2 0 012 2m0 10a2 2 0 002 2h2a2 2 0 002-2M9 7a2 2 0 012-2h2a2 2 0 012 2m0 10V7m0 10a2 2 0 002 2h2a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v16a2 2 0 002 2h2a2 2 0 002-2z"/>
        </svg>
      `;
    } else {
      return `
        <svg class="h-6 w-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
        </svg>
      `;
    }
  }

  timeAgo(date) {
    const now = new Date();
    const diffInSeconds = Math.floor((now - date) / 1000);
    
    if (diffInSeconds < 60) return 'Just now';
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutes ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
    return `${Math.floor(diffInSeconds / 86400)} days ago`;
  }

  async detectCurrentDevice() {
    const userAgent = navigator.userAgent;
    const deviceName = this.parseDeviceName(userAgent);
    
    this.currentDeviceTarget.textContent = deviceName;
    
    // Try to get IP address (this requires an external service in production)
    try {
      const ipResponse = await fetch('https://api.ipify.org?format=json');
      const ipData = await ipResponse.json();
      this.currentIpTarget.textContent = ipData.ip;
    } catch (error) {
      this.currentIpTarget.textContent = 'Unknown';
    }
  }

  parseDeviceName(userAgent) {
    if (/Mobile|Android|iPhone|iPad/i.test(userAgent)) {
      if (/iPhone/i.test(userAgent)) return 'iPhone';
      if (/iPad/i.test(userAgent)) return 'iPad';
      if (/Android/i.test(userAgent)) return 'Android Device';
      return 'Mobile Device';
    }
    
    if (/Chrome/i.test(userAgent)) return 'Chrome Browser';
    if (/Firefox/i.test(userAgent)) return 'Firefox Browser';
    if (/Safari/i.test(userAgent)) return 'Safari Browser';
    if (/Edge/i.test(userAgent)) return 'Edge Browser';
    
    return 'Desktop Browser';
  }

  async refreshSessions() {
    this.showLoading();
    await this.loadSessions();
    this.hideLoading();
    this.showSuccess('Sessions refreshed');
  }

  async revokeSession(event) {
    const deviceId = event.target.dataset.deviceId;
    
    if (!confirm('Are you sure you want to end this session?')) {
      return;
    }

    try {
      const response = await this.makeAuthenticatedRequest('/api/auth/revoke_session', {
        method: 'DELETE',
        body: JSON.stringify({ device_id: deviceId })
      });

      if (response.ok) {
        this.showSuccess('Session ended successfully');
        await this.loadSessions();
      } else {
        const data = await response.json();
        this.showError(data.error || 'Failed to end session');
      }
    } catch (error) {
      console.error('Error revoking session:', error);
      this.showError('Failed to end session');
    }
  }

  async logoutAllOther() {
    if (!confirm('Are you sure you want to end all other sessions? This will log you out of all other devices.')) {
      return;
    }

    try {
      const response = await this.makeAuthenticatedRequest('/api/auth/logout_all', {
        method: 'DELETE'
      });

      if (response.ok) {
        this.showSuccess('All other sessions ended successfully');
        await this.loadSessions();
      } else {
        const data = await response.json();
        this.showError(data.error || 'Failed to end sessions');
      }
    } catch (error) {
      console.error('Error ending all sessions:', error);
      this.showError('Failed to end sessions');
    }
  }

  async makeAuthenticatedRequest(url, options = {}) {
    const token = localStorage.getItem('access_token');
    
    const defaultOptions = {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content
      }
    };

    return fetch(url, { ...defaultOptions, ...options });
  }

  showLoading() {
    // Add loading state if needed
  }

  hideLoading() {
    // Remove loading state
  }

  showSuccess(message) {
    this.showToast(message, 'success');
  }

  showError(message) {
    this.showToast(message, 'error');
  }

  showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-x-full ${this.getToastClasses(type)}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    setTimeout(() => toast.classList.remove('translate-x-full'), 10);
    
    setTimeout(() => {
      toast.classList.add('translate-x-full');
      setTimeout(() => document.body.removeChild(toast), 300);
    }, 5000);
  }

  getToastClasses(type) {
    switch (type) {
      case 'success':
        return 'bg-green-500 text-white';
      case 'error':
        return 'bg-red-500 text-white';
      case 'info':
      default:
        return 'bg-blue-500 text-white';
    }
  }
}
```

## 📌 Commit 60.6: Agregar Rutas y Configuración Final

🔹 **Mensaje de commit:**
```
feat(auth-refresh): agrega rutas API y configuración para sistema completo de Refresh Tokens
```

**Agregar rutas** en `config/routes.rb`:
```ruby
Rails.application.routes.draw do
  # Rodauth routes
  mount RodauthApp, at: "/auth"
  
  # API routes for token management
  namespace :api do
    namespace :auth do
      post :login
      post :web3_login
      post :refresh
      delete :logout
      delete :logout_all
      get :sessions
      delete :revoke_session
    end
  end
  
  # Web3 specific routes
  namespace :auth do
    get :web3_nonce, to: 'web3_auth#nonce'
    get :sessions, to: 'auth#sessions'
  end
  
  # Your application routes
  root 'home#index'
end
```

**Configurar Redis para caching** en `config/application.rb`:
```ruby
config.cache_store = :redis_cache_store, {
  url: ENV.fetch('REDIS_URL', 'redis://localhost:6379/1'),
  expires_in: 30.days
}
```

## 📝 Ejemplos de Uso y Testing

### Ejemplo de Login con Refresh Token

```bash
# Traditional login
curl -X POST "http://localhost:3000/api/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "user@example.com",
    "password": "password123"
  }'

# Web3 login
curl -X POST "http://localhost:3000/api/auth/web3_login" \
  -H "Content-Type: application/json" \
  -d '{
    "wallet_address": "0x123...",
    "signature": "0xabc...",
    "nonce": "random_nonce_123"
  }'
```

**Response:**
```json
{
  "message": "Login successful",
  "user": {
    "id": 1,
    "email": "user@example.com",
    "wallet_address": "0x123...",
    "mfa_enabled": true
  },
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_in": 900
}
```

### Ejemplo de Refresh Token

```bash
curl -X POST "http://localhost:3000/api/auth/refresh" \
  -H "Content-Type: application/json" \
  -d '{
    "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }'
```

### Ejemplo de Gestión de Sesiones

```bash
# Get active sessions
curl -X GET "http://localhost:3000/api/auth/sessions" \
  -H "Authorization: Bearer ACCESS_TOKEN"

# Revoke specific session
curl -X DELETE "http://localhost:3000/api/auth/revoke_session" \
  -H "Authorization: Bearer ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"device_id": "device_uuid_123"}'

# Logout from all devices
curl -X DELETE "http://localhost:3000/api/auth/logout_all" \
  -H "Authorization: Bearer ACCESS_TOKEN"
```

## 🎯 Ventajas de la Implementación

1. **🔒 Seguridad Avanzada**: Rotación automática de tokens y revocación granular
2. **📱 Gestión de Dispositivos**: Rastreo y control de sesiones por dispositivo
3. **🌐 Web3 Compatible**: Funciona perfectamente con wallets y Smart Contracts
4. **⚡ Performance Optimizada**: Redis caching para operaciones rápidas
5. **🛡️ Protección contra Ataques**: Prevención de replay attacks y token reutilización
6. **📊 Auditoría Completa**: Logging detallado de todas las operaciones de tokens

Esta implementación proporciona un sistema robusto y seguro de Refresh Tokens que se integra perfectamente con Rodauth y soporta tanto autenticación tradicional como Web3, ofreciendo control granular sobre sesiones y dispositivos.