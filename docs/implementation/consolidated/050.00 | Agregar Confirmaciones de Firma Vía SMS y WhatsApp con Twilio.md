# âœ… Paso 50: Agregar Confirmaciones de Firma VÃ­a SMS y WhatsApp con Twilio

> **ARCHIVO CONSOLIDADO** - Combina SMS y WhatsApp para cobertura completa de notificaciones

Ahora agregaremos notificaciones vÃ­a SMS y WhatsApp con Twilio, permitiendo que los firmantes reciban alertas en su telÃ©fono cuando un contrato sea ejecutado en Gnosis Safe.
âœ… Twilio SMS API â†’ Para enviar notificaciones por mensaje de texto.
âœ… Twilio WhatsApp API â†’ Para enviar alertas vÃ­a WhatsApp.
âœ… Background Jobs (Sidekiq) â†’ Para procesar las notificaciones sin bloquear la app.
âœ… Turbo Streams + Stimulus.js â†’ Para actualizar la UI en tiempo real.

## ğŸ“Œ Commit 50.1: Configurar Twilio para EnvÃ­o de SMS y WhatsApp
ğŸ”¹ **Mensaje de commit:**
```
feat(notifications): configura Twilio para enviar notificaciones vÃ­a SMS y WhatsApp
```

ğŸ”¹ **Contenido del commit:**

### Agregar Credenciales de Twilio en config/credentials.yml.enc
```bash
rails credentials:edit

# Agregar:
twilio:
  account_sid: "YOUR_TWILIO_ACCOUNT_SID"
  auth_token: "YOUR_TWILIO_AUTH_TOKEN"
  phone_number: "+YOUR_TWILIO_PHONE_NUMBER"
  whatsapp_number: "whatsapp:+14155238886"  # NÃºmero oficial de Twilio para WhatsApp
```

### Instalar Twilio gem
```bash
echo "gem 'twilio-ruby', '~> 6.0'" >> Gemfile
bundle install
```

ğŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(notifications): configura Twilio para enviar notificaciones vÃ­a SMS y WhatsApp"
```

## ğŸ“Œ Commit 50.2: Crear Servicio para Enviar SMS con Twilio
ğŸ”¹ **Mensaje de commit:**
```
feat(notifications): agrega servicio para enviar notificaciones por SMS con Twilio
```

ğŸ”¹ **Contenido del commit:**

### Definir TwilioSmsService en app/services/twilio_sms_service.rb
```ruby
require "twilio-ruby"

class TwilioSmsService
  class << self
    def send_sms(phone_number, message, options = {})
      return false unless phone_number.present? && message.present?
      
      begin
        client = build_client
        
        response = client.messages.create(
          from: Rails.application.credentials.dig(:twilio, :phone_number),
          to: format_phone_number(phone_number),
          body: truncate_message(message),
          **options
        )
        
        log_success(phone_number, message, response.sid)
        response
      rescue Twilio::REST::RestError => e
        log_error(phone_number, message, e.message)
        false
      rescue => e
        Rails.logger.error "Unexpected error sending SMS: #{e.message}"
        false
      end
    end
    
    def send_contract_notification(phone_number, contract_hash, status = "executed")
      message = build_contract_message(contract_hash, status)
      send_sms(phone_number, message)
    end
    
    def send_signature_request(phone_number, contract_hash, requester_name = nil)
      message = build_signature_request_message(contract_hash, requester_name)
      send_sms(phone_number, message)
    end
    
    private
    
    def build_client
      Twilio::REST::Client.new(
        Rails.application.credentials.dig(:twilio, :account_sid),
        Rails.application.credentials.dig(:twilio, :auth_token)
      )
    end
    
    def format_phone_number(phone)
      # Asegurar formato internacional
      phone = phone.gsub(/[^\d+]/, '')
      phone.start_with?('+') ? phone : "+#{phone}"
    end
    
    def truncate_message(message, limit = 1600)
      # SMS tiene lÃ­mite de 1600 caracteres
      message.length > limit ? "#{message[0..limit-4]}..." : message
    end
    
    def build_contract_message(contract_hash, status)
      case status
      when "executed"
        "âœ… Contrato #{contract_hash[0..10]}... ejecutado en Gnosis Safe. Revisa la transacciÃ³n en la Blockchain."
      when "pending_signature"
        "âŒ› Contrato #{contract_hash[0..10]}... requiere tu firma en Gnosis Safe."
      when "cancelled"
        "âŒ Contrato #{contract_hash[0..10]}... ha sido cancelado."
      else
        "ğŸ“ ActualizaciÃ³n del contrato #{contract_hash[0..10]}...: #{status}"
      end
    end
    
    def build_signature_request_message(contract_hash, requester_name)
      requester = requester_name ? " por #{requester_name}" : ""
      "ğŸ” Se requiere tu firma#{requester} para el contrato #{contract_hash[0..10]}... en Gnosis Safe. Accede al dashboard para firmar."
    end
    
    def log_success(phone, message, sid)
      Rails.logger.info "SMS enviado exitosamente a #{phone}: #{sid}"
    end
    
    def log_error(phone, message, error)
      Rails.logger.error "Error enviando SMS a #{phone}: #{error}"
    end
  end
end
```

ğŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(notifications): agrega servicio para enviar notificaciones por SMS con Twilio"
```

## ğŸ“Œ Commit 50.3: Crear Servicio para Enviar Mensajes de WhatsApp con Twilio
ğŸ”¹ **Mensaje de commit:**
```
feat(notifications): agrega servicio para enviar notificaciones por WhatsApp con Twilio
```

ğŸ”¹ **Contenido del commit:**

### Definir TwilioWhatsappService en app/services/twilio_whatsapp_service.rb
```ruby
require "twilio-ruby"

class TwilioWhatsappService
  class << self
    def send_whatsapp(phone_number, message, options = {})
      return false unless phone_number.present? && message.present?
      
      begin
        client = build_client
        
        response = client.messages.create(
          from: Rails.application.credentials.dig(:twilio, :whatsapp_number),
          to: format_whatsapp_number(phone_number),
          body: message,
          **options
        )
        
        log_success(phone_number, message, response.sid)
        response
      rescue Twilio::REST::RestError => e
        log_error(phone_number, message, e.message)
        false
      rescue => e
        Rails.logger.error "Unexpected error sending WhatsApp: #{e.message}"
        false
      end
    end
    
    def send_contract_notification(phone_number, contract_hash, status = "executed")
      message = build_contract_message(contract_hash, status)
      send_whatsapp(phone_number, message)
    end
    
    def send_signature_request(phone_number, contract_hash, requester_name = nil)
      message = build_signature_request_message(contract_hash, requester_name)
      send_whatsapp(phone_number, message)
    end
    
    def send_rich_contract_notification(phone_number, contract_data)
      message = build_rich_message(contract_data)
      send_whatsapp(phone_number, message)
    end
    
    private
    
    def build_client
      Twilio::REST::Client.new(
        Rails.application.credentials.dig(:twilio, :account_sid),
        Rails.application.credentials.dig(:twilio, :auth_token)
      )
    end
    
    def format_whatsapp_number(phone)
      phone = phone.gsub(/[^\d+]/, '')
      formatted = phone.start_with?('+') ? phone : "+#{phone}"
      "whatsapp:#{formatted}"
    end
    
    def build_contract_message(contract_hash, status)
      case status
      when "executed"
        "âœ… *Contrato Ejecutado*\n\n" \
        "ğŸ“ Hash: `#{contract_hash[0..10]}...`\n" \
        "ğŸ”— Estado: Ejecutado en Gnosis Safe\n" \
        "ğŸš€ La transacciÃ³n ha sido enviada a la Blockchain\n\n" \
        "Revisa los detalles en tu dashboard."
      when "pending_signature"
        "âŒ› *Firma Requerida*\n\n" \
        "ğŸ“ Hash: `#{contract_hash[0..10]}...`\n" \
        "âœï¸ Estado: Esperando tu firma\n" \
        "ğŸ”’ Accede a Gnosis Safe para firmar\n\n" \
        "Tu firma es necesaria para continuar."
      when "cancelled"
        "âŒ *Contrato Cancelado*\n\n" \
        "ğŸ“ Hash: `#{contract_hash[0..10]}...`\n" \
        "ğŸš« Estado: Cancelado\n\n" \
        "El contrato ha sido cancelado por uno de los firmantes."
      else
        "ğŸ“ *ActualizaciÃ³n de Contrato*\n\n" \
        "Hash: `#{contract_hash[0..10]}...`\n" \
        "Estado: #{status}\n\n" \
        "Revisa tu dashboard para mÃ¡s detalles."
      end
    end
    
    def build_signature_request_message(contract_hash, requester_name)
      requester = requester_name ? "\nğŸ‘¤ Solicitado por: *#{requester_name}*" : ""
      
      "ğŸ” *Solicitud de Firma*\n\n" \
      "ğŸ“ Hash: `#{contract_hash[0..10]}...`" \
      "#{requester}\n\n" \
      "âœï¸ Por favor, accede a tu dashboard de Gnosis Safe para firmar este contrato.\n\n" \
      "ğŸ”— Dashboard: [Acceder](https://app.safe.global)"
    end
    
    def build_rich_message(contract_data)
      "ğŸ“Š *Detalles del Contrato*\n\n" \
      "ğŸ“ Hash: `#{contract_data[:hash][0..10]}...`\n" \
      "ğŸ“… Fecha: #{contract_data[:created_at]&.strftime('%d/%m/%Y %H:%M')}\n" \
      "ğŸ’° Valor: #{contract_data[:value] || '0'} ETH\n" \
      "ğŸ‘¥ Firmas: #{contract_data[:confirmations_count]}/#{contract_data[:threshold]}\n" \
      "ğŸ¨ Estado: #{contract_data[:status]}\n\n" \
      "Accede a tu dashboard para mÃ¡s detalles."
    end
    
    def log_success(phone, message, sid)
      Rails.logger.info "WhatsApp enviado exitosamente a #{phone}: #{sid}"
    end
    
    def log_error(phone, message, error)
      Rails.logger.error "Error enviando WhatsApp a #{phone}: #{error}"
    end
  end
end
```

ğŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(notifications): agrega servicio para enviar notificaciones por WhatsApp con Twilio"
```

## ğŸ“Œ Commit 50.4: Crear Job para Enviar SMS y WhatsApp AutomÃ¡ticamente
ğŸ”¹ **Mensaje de commit:**
```
feat(notifications): agrega job para enviar notificaciones por SMS y WhatsApp
```

ğŸ”¹ **Contenido del commit:**

### Crear Job SendContractTwilioJob
```bash
rails g job send_contract_twilio
```

### Modificar app/jobs/send_contract_twilio_job.rb
```ruby
class SendContractTwilioJob < ApplicationJob
  queue_as :notifications
  
  retry_on Twilio::REST::RestError, wait: :exponentially_longer, attempts: 3
  retry_on StandardError, wait: 30.seconds, attempts: 2
  
  def perform(phone_number, contract_hash, notification_type = "executed", extra_data = {})
    return unless phone_number.present? && contract_hash.present?
    
    case notification_type
    when "executed"
      send_execution_notifications(phone_number, contract_hash)
    when "signature_request"
      send_signature_request(phone_number, contract_hash, extra_data[:requester_name])
    when "rich_notification"
      send_rich_notifications(phone_number, extra_data)
    else
      send_generic_notifications(phone_number, contract_hash, notification_type)
    end
    
    # Registrar el envÃ­o en la base de datos
    log_notification_sent(phone_number, contract_hash, notification_type)
  end
  
  private
  
  def send_execution_notifications(phone_number, contract_hash)
    # Enviar por ambos canales
    sms_result = TwilioSmsService.send_contract_notification(phone_number, contract_hash, "executed")
    whatsapp_result = TwilioWhatsappService.send_contract_notification(phone_number, contract_hash, "executed")
    
    Rails.logger.info "Contract execution notification sent to #{phone_number}: SMS=#{!!sms_result}, WhatsApp=#{!!whatsapp_result}"
  end
  
  def send_signature_request(phone_number, contract_hash, requester_name)
    # Para solicitudes de firma, priorizar WhatsApp por su formato enriquecido
    whatsapp_result = TwilioWhatsappService.send_signature_request(phone_number, contract_hash, requester_name)
    
    # Si WhatsApp falla, enviar por SMS como respaldo
    unless whatsapp_result
      TwilioSmsService.send_signature_request(phone_number, contract_hash, requester_name)
    end
  end
  
  def send_rich_notifications(phone_number, contract_data)
    # Notificaciones enriquecidas solo por WhatsApp
    TwilioWhatsappService.send_rich_contract_notification(phone_number, contract_data)
  end
  
  def send_generic_notifications(phone_number, contract_hash, status)
    TwilioSmsService.send_contract_notification(phone_number, contract_hash, status)
    TwilioWhatsappService.send_contract_notification(phone_number, contract_hash, status)
  end
  
  def log_notification_sent(phone_number, contract_hash, notification_type)
    NotificationLog.create!(
      recipient_phone: phone_number,
      contract_hash: contract_hash,
      notification_type: notification_type,
      channel: "twilio",
      sent_at: Time.current
    )
  rescue => e
    Rails.logger.error "Error logging notification: #{e.message}"
  end
end
```

### Crear modelo NotificationLog
```bash
rails g model NotificationLog recipient_phone:string contract_hash:string notification_type:string channel:string sent_at:datetime
rails db:migrate
```

### Modificar app/models/notification_log.rb
```ruby
class NotificationLog < ApplicationRecord
  validates :recipient_phone, :contract_hash, :notification_type, :channel, :sent_at, presence: true
  
  scope :recent, -> { order(sent_at: :desc) }
  scope :by_contract, ->(hash) { where(contract_hash: hash) }
  scope :by_phone, ->(phone) { where(recipient_phone: phone) }
  scope :by_channel, ->(channel) { where(channel: channel) }
  
  def self.notification_stats(contract_hash)
    by_contract(contract_hash).group(:channel).count
  end
end
```

ğŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(notifications): agrega job para enviar notificaciones por SMS y WhatsApp"
```

## ğŸ“Œ Commit 50.5: Integrar EnvÃ­o de SMS y WhatsApp en Webhooks de Gnosis Safe
ğŸ”¹ **Mensaje de commit:**
```
feat(notifications): dispara notificaciÃ³n por SMS y WhatsApp cuando un contrato es ejecutado en Gnosis Safe
```

ğŸ”¹ **Contenido del commit:**

### Modificar GnosisSafeWebhooksController para Incluir Twilio
```ruby
class GnosisSafeWebhooksController < ApplicationController
  skip_before_action :verify_authenticity_token
  before_action :verify_webhook_signature, if: -> { webhook_secret.present? }
  
  def receive
    payload = JSON.parse(request.body.read)
    
    case payload["event"]
    when "MULTISIG_TRANSACTION_EXECUTED"
      handle_transaction_executed(payload)
    when "MULTISIG_TRANSACTION_CONFIRMATION"
      handle_transaction_confirmation(payload)
    when "MULTISIG_TRANSACTION_PENDING"
      handle_transaction_pending(payload)
    else
      Rails.logger.warn "Unhandled webhook event: #{payload['event']}"
    end
    
    render json: { status: "ok" }
  rescue JSON::ParserError => e
    Rails.logger.error "Invalid JSON payload: #{e.message}"
    render json: { error: "Invalid JSON" }, status: :bad_request
  rescue => e
    Rails.logger.error "Webhook processing error: #{e.message}"
    render json: { error: "Internal server error" }, status: :internal_server_error
  end
  
  private
  
  def handle_transaction_executed(payload)
    contract_hash = payload["safeTxHash"]
    safe_address = payload["address"]
    
    notify_contract_executed(contract_hash, safe_address, payload)
  end
  
  def handle_transaction_confirmation(payload)
    contract_hash = payload["safeTxHash"]
    safe_address = payload["address"]
    confirmations_count = payload["confirmations"]&.length || 0
    threshold = payload["confirmationsRequired"] || 2
    
    # Si alcanza el umbral, notificar que estÃ¡ listo para ejecutar
    if confirmations_count >= threshold
      notify_ready_for_execution(contract_hash, safe_address)
    end
  end
  
  def handle_transaction_pending(payload)
    contract_hash = payload["safeTxHash"]
    safe_address = payload["address"]
    
    notify_signature_required(contract_hash, safe_address, payload)
  end
  
  def notify_contract_executed(contract_hash, safe_address, payload)
    # Obtener firmantes y sus telÃ©fonos
    signers = get_contract_signers(contract_hash, safe_address)
    
    signers.each do |signer|
      next unless signer[:phone_number].present?
      
      # Enviar notificaciÃ³n por SMS y WhatsApp
      SendContractTwilioJob.perform_later(
        signer[:phone_number], 
        contract_hash, 
        "executed"
      )
    end
    
    # Notificar en otros canales
    broadcast_to_other_channels(contract_hash, "executed", payload)
  end
  
  def notify_signature_required(contract_hash, safe_address, payload)
    # Obtener firmantes pendientes
    pending_signers = get_pending_signers(contract_hash, safe_address)
    
    pending_signers.each do |signer|
      next unless signer[:phone_number].present?
      
      SendContractTwilioJob.perform_later(
        signer[:phone_number],
        contract_hash,
        "signature_request",
        { requester_name: get_requester_name(payload) }
      )
    end
  end
  
  def notify_ready_for_execution(contract_hash, safe_address)
    # Notificar a los propietarios que la transacciÃ³n estÃ¡ lista para ejecutar
    owners = get_safe_owners(safe_address)
    
    owners.each do |owner|
      next unless owner[:phone_number].present?
      
      SendContractTwilioJob.perform_later(
        owner[:phone_number],
        contract_hash,
        "ready_for_execution"
      )
    end
  end
  
  def broadcast_to_other_channels(contract_hash, status, payload)
    # Notificar en Telegram, Discord y UI
    message = build_broadcast_message(contract_hash, status, payload)
    
    TelegramNotifierService.send_message(message) if defined?(TelegramNotifierService)
    DiscordNotifierService.send_message(message) if defined?(DiscordNotifierService)
    
    # WebSocket para UI en tiempo real
    ActionCable.server.broadcast("gnosis_safe_notifications", {
      contract_hash: contract_hash,
      status: status,
      timestamp: Time.current.iso8601,
      payload: payload
    })
  end
  
  def get_contract_signers(contract_hash, safe_address)
    # Implementar lÃ³gica para obtener firmantes desde la BD o API de Safe
    # Por ahora, ejemplo estÃ¡tico
    [
      { email: "user1@example.com", phone_number: "+1234567890", address: "0x123..." },
      { email: "user2@example.com", phone_number: "+0987654321", address: "0x456..." }
    ]
  end
  
  def get_pending_signers(contract_hash, safe_address)
    # LÃ³gica para obtener firmantes que aÃºn no han firmado
    get_contract_signers(contract_hash, safe_address)
  end
  
  def get_safe_owners(safe_address)
    # LÃ³gica para obtener propietarios del Safe
    get_contract_signers(nil, safe_address)
  end
  
  def get_requester_name(payload)
    # Extraer el nombre del solicitante del payload si estÃ¡ disponible
    payload.dig("initiator", "name") || "Un miembro del equipo"
  end
  
  def build_broadcast_message(contract_hash, status, payload)
    case status
    when "executed"
      "âœ… *Contrato Ejecutado en Gnosis Safe*\n" \
      "ğŸ“ Hash: #{contract_hash}\n" \
      "ğŸš€ TransacciÃ³n enviada a la Blockchain"
    when "ready_for_execution"
      "ğŸ† *Contrato Listo para Ejecutar*\n" \
      "ğŸ“ Hash: #{contract_hash}\n" \
      "âœ… Todas las firmas requeridas han sido recolectadas"
    else
      "ğŸ“ *ActualizaciÃ³n de Contrato*\n" \
      "Hash: #{contract_hash}\n" \
      "Estado: #{status}"
    end
  end
  
  def verify_webhook_signature
    signature = request.headers['X-Webhook-Signature']
    payload = request.body.read
    expected = OpenSSL::HMAC.hexdigest('SHA256', webhook_secret, payload)
    
    unless Rack::Utils.secure_compare(signature, "sha256=#{expected}")
      render json: { error: "Unauthorized" }, status: :unauthorized
      return false
    end
    
    true
  end
  
  def webhook_secret
    Rails.application.credentials.dig(:gnosis_safe, :webhook_secret)
  end
end
```

### Agregar rutas para webhooks
```ruby
# config/routes.rb
Rails.application.routes.draw do
  post "/webhooks/gnosis_safe", to: "gnosis_safe_webhooks#receive"
end
```

ğŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(notifications): dispara notificaciÃ³n por SMS y WhatsApp cuando un contrato es ejecutado en Gnosis Safe"
```

## ğŸ“ ExplicaciÃ³n y CÃ³digo Generado

### Ejemplo de NotificaciÃ³n por SMS y WhatsApp en Rails Console
```ruby
# Enviar notificaciÃ³n directa
SendContractTwilioJob.perform_now("+1234567890", "0x123456...", "executed")

# Enviar solicitud de firma
SendContractTwilioJob.perform_now(
  "+1234567890", 
  "0x123456...", 
  "signature_request",
  { requester_name: "Alice" }
)

# Verificar logs de notificaciones
NotificationLog.by_contract("0x123456...").recent
```

### Ejemplo de Disparo de NotificaciÃ³n AutomÃ¡tica
```bash
curl -X POST "https://your-rails-app.com/webhooks/gnosis_safe" \
  -H "Content-Type: application/json" \
  -H "X-Webhook-Signature: sha256=your_signature" \
  -d '{
    "event": "MULTISIG_TRANSACTION_EXECUTED",
    "safeTxHash": "0x123456...",
    "address": "0x789abc..."
  }'
```

### Resultados esperados:

**SMS recibido:**
```
âœ… Contrato 0x123456... ejecutado en Gnosis Safe. Revisa la transacciÃ³n en la Blockchain.
```

**WhatsApp recibido:**
```
âœ… *Contrato Ejecutado*

ğŸ“ Hash: `0x123456...`
ğŸ”— Estado: Ejecutado en Gnosis Safe
ğŸš€ La transacciÃ³n ha sido enviada a la Blockchain

Revisa los detalles en tu dashboard.
```

## ğŸ”§ ConfiguraciÃ³n de ProducciÃ³n

### Variables de Entorno Requeridas
```bash
# Twilio Configuration
TWILIO_ACCOUNT_SID=your_account_sid
TWILIO_AUTH_TOKEN=your_auth_token
TWILIO_PHONE_NUMBER=+1234567890
TWILIO_WHATSAPP_NUMBER=whatsapp:+14155238886

# Webhook Security
GNOSIS_SAFE_WEBHOOK_SECRET=your_webhook_secret

# Background Jobs
REDIS_URL=redis://localhost:6379/0
```

### ConfiguraciÃ³n de Sidekiq para Background Jobs
```yaml
# config/schedule.rb (si usas whenever gem)
every 5.minutes do
  runner "NotificationLog.where('sent_at < ?', 1.day.ago).delete_all"
end
```

### Monitoreo y MÃ©tricas
```ruby
# En Rails Console
# Verificar estadÃ­sticas de notificaciones
NotificationLog.group(:notification_type).count
NotificationLog.group(:channel).count

# Ãšltimas notificaciones enviadas
NotificationLog.recent.limit(10)

# Notificaciones de un contrato especÃ­fico
NotificationLog.notification_stats("0x123456...")
```