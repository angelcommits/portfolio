# ✅ Paso 40: Integrar Firma Digital con Hardware Wallets (Ledger y Trezor)

> **ARCHIVO CONSOLIDADO** - Combina soporte para Trezor y Ledger para máxima compatibilidad con hardware wallets

Ahora agregaremos soporte para firma digital con dispositivos físicos como Trezor y Ledger, permitiendo a los usuarios firmar transacciones con máxima seguridad sin exponer sus claves privadas.
✅ Trezor Connect SDK → Librería oficial para interactuar con dispositivos Trezor.
✅ Ledger SDK → Soporte para dispositivos Ledger a través de Web3.js y ethers.js.
✅ Firma EIP-712 → Para transacciones seguras sin riesgo de phishing.
✅ Soporte en Web3.js → Integración nativa con MetaMask y dApps.
✅ Autenticación por Hardware → Protección avanzada contra hackeos.

## 📌 Commit 40.1: Instalar Hardware Wallet SDKs en el Frontend
🔹 **Mensaje de commit:**
```
feat(hardware-wallets): instala Trezor Connect y Ledger SDKs para firma digital segura
```

🔹 **Contenido del commit:**

### Instalar Trezor Connect en app/javascript/packs/trezor.js
```javascript
import TrezorConnect from "@trezor/connect-web";

TrezorConnect.init({
  manifest: {
    email: "soporte@example.com",
    appUrl: "http://localhost:3000"
  }
});

export default TrezorConnect;
```

### Instalar Ledger Support en app/javascript/packs/ledger.js
```javascript
import { ethers } from "ethers";
import LedgerApp from "@ledgerhq/hw-app-eth";
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";

class LedgerWallet {
  constructor() {
    this.transport = null;
    this.app = null;
  }

  async connect() {
    try {
      this.transport = await TransportWebUSB.create();
      this.app = new LedgerApp(this.transport);
      return true;
    } catch (error) {
      console.error("Error conectando Ledger:", error);
      return false;
    }
  }

  async getAddress(path = "44'/60'/0'/0/0") {
    if (!this.app) await this.connect();
    const result = await this.app.getAddress(path);
    return result.address;
  }

  async signTransaction(path, transaction) {
    if (!this.app) await this.connect();
    const signature = await this.app.signTransaction(path, transaction);
    return signature;
  }

  async disconnect() {
    if (this.transport) {
      await this.transport.close();
      this.transport = null;
      this.app = null;
    }
  }
}

export default new LedgerWallet();
```

### Package.json dependencies
```json
{
  "dependencies": {
    "@trezor/connect-web": "^9.0.0",
    "@ledgerhq/hw-app-eth": "^6.0.0",
    "@ledgerhq/hw-transport-webusb": "^6.0.0",
    "ethers": "^6.0.0",
    "web3": "^4.0.0"
  }
}
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): instala Trezor Connect y Ledger SDKs para firma digital segura"
```

## 📌 Commit 40.2: Agregar Función para Firmar Contratos con Hardware Wallets
🔹 **Mensaje de commit:**
```
feat(hardware-wallets): agrega función para firmar contratos usando Trezor y Ledger
```

🔹 **Contenido del commit:**

### Crear app/javascript/packs/hardware_wallet_sign.js
```javascript
import TrezorConnect from "./trezor";
import LedgerWallet from "./ledger";
import Web3 from "web3";

class HardwareWalletSigner {
  constructor() {
    this.web3 = new Web3();
  }

  async signContractWithTrezor(contractHash) {
    try {
      const response = await TrezorConnect.ethereumSignMessage({
        path: "m/44'/60'/0'/0/0",
        message: contractHash,
        hex: false
      });

      if (response.success) {
        const signature = response.payload.signature;
        const userAddress = response.payload.address;
        
        await this.submitSignature({
          contract_hash: contractHash,
          user_address: userAddress,
          signature: signature,
          wallet_type: "trezor"
        });
      } else {
        throw new Error("Firma fallida: " + response.payload.error);
      }
    } catch (error) {
      console.error("Error firmando con Trezor:", error);
      alert("Error firmando contrato con Trezor: " + error.message);
    }
  }

  async signContractWithLedger(contractHash) {
    try {
      const connected = await LedgerWallet.connect();
      if (!connected) {
        throw new Error("No se pudo conectar con Ledger");
      }

      const userAddress = await LedgerWallet.getAddress();
      
      // Crear mensaje hash para firmar
      const messageHash = this.web3.utils.keccak256(contractHash);
      const signature = await LedgerWallet.signTransaction("44'/60'/0'/0/0", {
        to: userAddress,
        value: "0x0",
        data: messageHash,
        gasLimit: "0x5208",
        gasPrice: "0x1"
      });

      await this.submitSignature({
        contract_hash: contractHash,
        user_address: userAddress,
        signature: signature,
        wallet_type: "ledger"
      });

      await LedgerWallet.disconnect();
    } catch (error) {
      console.error("Error firmando con Ledger:", error);
      alert("Error firmando contrato con Ledger: " + error.message);
    }
  }

  async submitSignature(signatureData) {
    const response = await fetch("/contracts/sign_hardware_wallet", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify(signatureData)
    });

    const data = await response.json();
    
    if (response.ok) {
      alert(`Contrato firmado exitosamente: ${data.transaction_hash}`);
      window.location.reload(); // Refrescar para mostrar el estado actualizado
    } else {
      throw new Error(data.error || "Error desconocido");
    }
  }
}

const hardwareWalletSigner = new HardwareWalletSigner();

// Event listeners para los botones
document.addEventListener("DOMContentLoaded", () => {
  // Botón Trezor
  document.querySelectorAll(".sign-contract-trezor").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      await hardwareWalletSigner.signContractWithTrezor(contractHash);
    });
  });

  // Botón Ledger
  document.querySelectorAll(".sign-contract-ledger").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      await hardwareWalletSigner.signContractWithLedger(contractHash);
    });
  });

  // Botón genérico para detectar hardware wallet disponible
  document.querySelectorAll(".sign-contract-hardware").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      await hardwareWalletSigner.detectAndSign(contractHash);
    });
  });
});

export default hardwareWalletSigner;
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): agrega función para firmar contratos usando Trezor y Ledger"
```

## 📌 Commit 40.3: Crear Endpoint para Verificar Firmas de Hardware Wallets
🔹 **Mensaje de commit:**
```
feat(hardware-wallets): agrega endpoint para firmar contratos con hardware wallets y verificar autenticidad
```

🔹 **Contenido del commit:**

### Modificar ContractsController para Integrar Firma con Hardware Wallets
```ruby
class ContractsController < ApplicationController
  def sign_hardware_wallet
    contract_hash = params[:contract_hash]
    user_address = params[:user_address]
    signature = params[:signature]
    wallet_type = params[:wallet_type] # 'trezor' o 'ledger'
    
    # Verificar firma según el tipo de wallet
    valid = case wallet_type
            when 'trezor'
              SmartContractService.verify_trezor_signature(contract_hash, user_address, signature)
            when 'ledger'
              SmartContractService.verify_ledger_signature(contract_hash, user_address, signature)
            else
              false
            end
    
    if valid
      # Registrar la firma en la base de datos
      contract_signature = ContractSignature.create!(
        contract_hash: contract_hash,
        user_address: user_address,
        signature: signature,
        wallet_type: wallet_type,
        signed_at: Time.current
      )
      
      # Enviar transacción a la blockchain
      tx_hash = SmartContractService.sign_contract(
        user_address, 
        contract_hash, 
        signature,
        wallet_type
      )
      
      # Enviar notificaciones
      notify_contract_signed(contract_hash, user_address, wallet_type)
      
      render json: { 
        message: "Contrato firmado en Blockchain con #{wallet_type.capitalize}", 
        transaction_hash: tx_hash,
        signature_id: contract_signature.id
      }
    else
      render json: { error: "Firma inválida" }, status: :unauthorized
    end
  rescue => e
    Rails.logger.error "Error procesando firma de hardware wallet: #{e.message}"
    render json: { error: "Error interno del servidor" }, status: :internal_server_error
  end

  private

  def notify_contract_signed(contract_hash, user_address, wallet_type)
    # Notificar vía WebSockets
    ActionCable.server.broadcast("contract_#{contract_hash}", {
      event: "signature_added",
      user_address: user_address,
      wallet_type: wallet_type,
      timestamp: Time.current.iso8601
    })
    
    # Enviar notificación por email/SMS si está configurado
    user = User.find_by(wallet_address: user_address)
    if user
      UserNotification.with(
        message: "Contrato #{contract_hash} firmado con #{wallet_type.capitalize}"
      ).deliver(user)
    end
  end
end
```

### Agregar Ruta en config/routes.rb
```ruby
Rails.application.routes.draw do
  post "/contracts/sign_hardware_wallet", to: "contracts#sign_hardware_wallet"
end
```

### Crear Modelo ContractSignature
```ruby
class ContractSignature < ApplicationRecord
  validates :contract_hash, :user_address, :signature, :wallet_type, presence: true
  validates :wallet_type, inclusion: { in: %w[trezor ledger] }
  
  scope :by_contract, ->(hash) { where(contract_hash: hash) }
  scope :by_wallet_type, ->(type) { where(wallet_type: type) }
  
  def display_wallet_type
    wallet_type.capitalize
  end
end
```

### Migración para ContractSignature
```ruby
class CreateContractSignatures < ActiveRecord::Migration[7.0]
  def change
    create_table :contract_signatures do |t|
      t.string :contract_hash, null: false, index: true
      t.string :user_address, null: false
      t.text :signature, null: false
      t.string :wallet_type, null: false
      t.datetime :signed_at, null: false
      t.timestamps
    end
    
    add_index :contract_signatures, [:contract_hash, :user_address], unique: true
    add_index :contract_signatures, :wallet_type
  end
end
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): agrega endpoint para firmar contratos con hardware wallets y verificar autenticidad"
```

## 📌 Commit 40.4: Modificar Servicio de Smart Contracts para Verificar Firmas de Hardware Wallets
🔹 **Mensaje de commit:**
```
feat(hardware-wallets): agrega verificación de firmas con Trezor y Ledger en el servicio de Smart Contracts
```

🔹 **Contenido del commit:**

### Modificar SmartContractService en app/services/smart_contract_service.rb
```ruby
require "web3"
require "eth"

class SmartContractService
  INFURA_URL = Rails.application.credentials.dig(:ethereum, :infura_url)
  CONTRACT_ADDRESS = Rails.application.credentials.dig(:ethereum, :contract_address)
  
  def self.sign_contract(user_address, contract_hash, signature, wallet_type = nil)
    web3 = Web3::Eth::Rpc.new(host: INFURA_URL, port: 443, connect_options: { use_ssl: true })
    contract_abi = JSON.parse(File.read(Rails.root.join("config/contract_abi.json")))
    contract = web3.eth.contract(abi: contract_abi).at(CONTRACT_ADDRESS)
    
    # Incluir el tipo de wallet en los metadatos de la transacción
    tx_data = {
      from: user_address,
      gas: 200_000,
      gasPrice: web3.eth.gas_price,
      data: contract.sign_contract.call_data(contract_hash, signature)
    }
    
    # Agregar metadatos del wallet si está disponible
    if wallet_type
      tx_data[:memo] = "Signed with #{wallet_type}"
    end
    
    tx = contract.transact_and_wait.signContract(contract_hash, signature, tx_data)
    tx.transaction_hash
  end
  
  def self.verify_trezor_signature(contract_hash, user_address, signature)
    begin
      web3 = Web3::Eth::Rpc.new(host: INFURA_URL, port: 443, connect_options: { use_ssl: true })
      
      # Verificar usando el método estándar de recuperación de dirección
      recovered_address = web3.eth.personal.ec_recover(contract_hash, signature)
      recovered_address.downcase == user_address.downcase
    rescue => e
      Rails.logger.error "Error verificando firma Trezor: #{e.message}"
      false
    end
  end
  
  def self.verify_ledger_signature(contract_hash, user_address, signature)
    begin
      # Ledger usa un formato ligeramente diferente para las firmas
      # Verificar usando eth gem para mayor precisión
      key = Eth::Key.new
      message_hash = Eth::Util.keccak256(contract_hash)
      
      # Parsear la firma de Ledger
      signature_bytes = [signature.gsub('0x', '')].pack('H*')
      r = signature_bytes[0..31]
      s = signature_bytes[32..63]
      v = signature_bytes[64]
      
      # Recuperar la dirección pública
      recovered_key = Eth::Key.recover_compact(message_hash, signature_bytes)
      recovered_address = recovered_key.address
      
      recovered_address.downcase == user_address.downcase
    rescue => e
      Rails.logger.error "Error verificando firma Ledger: #{e.message}"
      false
    end
  end
  
  def self.get_contract_signatures(contract_hash)
    ContractSignature.by_contract(contract_hash).includes(:user)
  end
  
  def self.contract_fully_signed?(contract_hash, required_signatures = 2)
    signatures_count = ContractSignature.by_contract(contract_hash).count
    signatures_count >= required_signatures
  end
end
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): agrega verificación de firmas con Trezor y Ledger en el servicio de Smart Contracts"
```

## 📝 Explicación y Código Generado

### Ejemplo de Firma de Contrato con Trezor
1. El usuario hace clic en "Firmar Contrato con Trezor".
2. Trezor Connect solicita la firma del contrato en el hardware wallet.
3. El usuario confirma la firma en su dispositivo.
4. El backend verifica la firma y la registra en la blockchain.

### Ejemplo de Firma de Contrato con Ledger
1. El usuario conecta su Ledger y hace clic en "Firmar Contrato con Ledger".
2. El sistema solicita la firma en el dispositivo Ledger.
3. El usuario confirma la transacción en su Ledger.
4. La firma se verifica y se registra automáticamente.

### Ejemplo de Uso en Rails Console
```ruby
# Verificar firma de Trezor
SmartContractService.verify_trezor_signature(
  "0xContratoHash", 
  "0xUserWallet", 
  "0xFirmaDigital"
)

# Verificar firma de Ledger
SmartContractService.verify_ledger_signature(
  "0xContratoHash", 
  "0xUserWallet", 
  "0xFirmaDigitalLedger"
)

# Obtener todas las firmas de un contrato
SmartContractService.get_contract_signatures("0xContratoHash")

# Verificar si un contrato está completamente firmado
SmartContractService.contract_fully_signed?("0xContratoHash", 3)
```

### Ejemplo de Verificación de Firma con Hardware Wallet
```bash
curl -X POST "http://localhost:3000/contracts/sign_hardware_wallet" \
  -H "Content-Type: application/json" \
  -d '{
    "contract_hash": "0xContratoHash",
    "user_address": "0xUserWallet",
    "signature": "0xFirmaDigital",
    "wallet_type": "trezor"
  }'
```

### Respuesta Exitosa:
```json
{
  "message": "Contrato firmado en Blockchain con Trezor",
  "transaction_hash": "0xabc123...",
  "signature_id": 123
}
```

### Respuesta de Error:
```json
{
  "error": "Firma inválida"
}
```

## 🔧 Configuración y Deployment

### Variables de Entorno Requeridas
```bash
# Ethereum Configuration
ETHEREUM_INFURA_URL=https://mainnet.infura.io/v3/YOUR_PROJECT_ID
ETHEREUM_CONTRACT_ADDRESS=0xYourContractAddress

# Security
WEB3_PRIVATE_KEY=your_private_key_for_contract_deployment
```

### Configuración de Producción
```ruby
# En config/credentials.yml.enc
rails credentials:edit

# Agregar:
ethereum:
  infura_url: https://mainnet.infura.io/v3/YOUR_PROJECT_ID
  contract_address: 0xYourContractAddress
  private_key: your_private_key
```

### Verificación de Hardware Wallets en Desarrollo
```javascript
// En la consola del navegador
// Verificar Trezor
TrezorConnect.getFeatures().then(result => console.log(result));

// Verificar Ledger (requiere conexión USB)
LedgerWallet.connect().then(connected => console.log('Ledger connected:', connected));
```