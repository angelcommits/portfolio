# âœ… Paso 40: Integrar Firma Digital con Hardware Wallets (Ledger y Trezor)

> **ARCHIVO CONSOLIDADO** - Combina soporte para Trezor y Ledger para mÃ¡xima compatibilidad con hardware wallets

Ahora agregaremos soporte para firma digital con dispositivos fÃ­sicos como Trezor y Ledger, permitiendo a los usuarios firmar transacciones con mÃ¡xima seguridad sin exponer sus claves privadas.
âœ… Trezor Connect SDK â†’ LibrerÃ­a oficial para interactuar con dispositivos Trezor.
âœ… Ledger SDK â†’ Soporte para dispositivos Ledger a travÃ©s de Web3.js y ethers.js.
âœ… Firma EIP-712 â†’ Para transacciones seguras sin riesgo de phishing.
âœ… Soporte en Web3.js â†’ IntegraciÃ³n nativa con MetaMask y dApps.
âœ… AutenticaciÃ³n por Hardware â†’ ProtecciÃ³n avanzada contra hackeos.

## ðŸ“Œ Commit 40.1: Instalar Hardware Wallet SDKs en el Frontend
ðŸ”¹ **Mensaje de commit:**
```
feat(hardware-wallets): instala Trezor Connect y Ledger SDKs para firma digital segura
```

ðŸ”¹ **Contenido del commit:**

### Instalar Trezor Connect en app/javascript/packs/trezor.js
```javascript
import TrezorConnect from "@trezor/connect-web";

TrezorConnect.init({
  manifest: {
    email: "soporte@example.com",
    appUrl: "http://localhost:3000"
  }
});

export default TrezorConnect;
```

### Instalar Ledger Support en app/javascript/packs/ledger.js
```javascript
import { ethers } from "ethers";
import LedgerApp from "@ledgerhq/hw-app-eth";
import TransportWebUSB from "@ledgerhq/hw-transport-webusb";

class LedgerWallet {
  constructor() {
    this.transport = null;
    this.app = null;
  }

  async connect() {
    try {
      this.transport = await TransportWebUSB.create();
      this.app = new LedgerApp(this.transport);
      return true;
    } catch (error) {
      console.error("Error conectando Ledger:", error);
      return false;
    }
  }

  async getAddress(path = "44'/60'/0'/0/0") {
    if (!this.app) await this.connect();
    const result = await this.app.getAddress(path);
    return result.address;
  }

  async signTransaction(path, transaction) {
    if (!this.app) await this.connect();
    const signature = await this.app.signTransaction(path, transaction);
    return signature;
  }

  async disconnect() {
    if (this.transport) {
      await this.transport.close();
      this.transport = null;
      this.app = null;
    }
  }
}

export default new LedgerWallet();
```

### Package.json dependencies
```json
{
  "dependencies": {
    "@trezor/connect-web": "^9.0.0",
    "@ledgerhq/hw-app-eth": "^6.0.0",
    "@ledgerhq/hw-transport-webusb": "^6.0.0",
    "ethers": "^6.0.0",
    "web3": "^4.0.0"
  }
}
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): instala Trezor Connect y Ledger SDKs para firma digital segura"
```

## ðŸ“Œ Commit 40.2: Agregar FunciÃ³n para Firmar Contratos con Hardware Wallets
ðŸ”¹ **Mensaje de commit:**
```
feat(hardware-wallets): agrega funciÃ³n para firmar contratos usando Trezor y Ledger
```

ðŸ”¹ **Contenido del commit:**

### Crear app/javascript/packs/hardware_wallet_sign.js
```javascript
import TrezorConnect from "./trezor";
import LedgerWallet from "./ledger";
import Web3 from "web3";

class HardwareWalletSigner {
  constructor() {
    this.web3 = new Web3();
  }

  async signContractWithTrezor(contractHash) {
    try {
      const response = await TrezorConnect.ethereumSignMessage({
        path: "m/44'/60'/0'/0/0",
        message: contractHash,
        hex: false
      });

      if (response.success) {
        const signature = response.payload.signature;
        const userAddress = response.payload.address;
        
        await this.submitSignature({
          contract_hash: contractHash,
          user_address: userAddress,
          signature: signature,
          wallet_type: "trezor"
        });
      } else {
        throw new Error("Firma fallida: " + response.payload.error);
      }
    } catch (error) {
      console.error("Error firmando con Trezor:", error);
      alert("Error firmando contrato con Trezor: " + error.message);
    }
  }

  async signContractWithLedger(contractHash) {
    try {
      const connected = await LedgerWallet.connect();
      if (!connected) {
        throw new Error("No se pudo conectar con Ledger");
      }

      const userAddress = await LedgerWallet.getAddress();
      
      // Crear mensaje hash para firmar
      const messageHash = this.web3.utils.keccak256(contractHash);
      const signature = await LedgerWallet.signTransaction("44'/60'/0'/0/0", {
        to: userAddress,
        value: "0x0",
        data: messageHash,
        gasLimit: "0x5208",
        gasPrice: "0x1"
      });

      await this.submitSignature({
        contract_hash: contractHash,
        user_address: userAddress,
        signature: signature,
        wallet_type: "ledger"
      });

      await LedgerWallet.disconnect();
    } catch (error) {
      console.error("Error firmando con Ledger:", error);
      alert("Error firmando contrato con Ledger: " + error.message);
    }
  }

  async submitSignature(signatureData) {
    const response = await fetch("/contracts/sign_hardware_wallet", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CSRF-Token": document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify(signatureData)
    });

    const data = await response.json();
    
    if (response.ok) {
      alert(`Contrato firmado exitosamente: ${data.transaction_hash}`);
      window.location.reload(); // Refrescar para mostrar el estado actualizado
    } else {
      throw new Error(data.error || "Error desconocido");
    }
  }
}

const hardwareWalletSigner = new HardwareWalletSigner();

// Event listeners para los botones
document.addEventListener("DOMContentLoaded", () => {
  // BotÃ³n Trezor
  document.querySelectorAll(".sign-contract-trezor").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      await hardwareWalletSigner.signContractWithTrezor(contractHash);
    });
  });

  // BotÃ³n Ledger
  document.querySelectorAll(".sign-contract-ledger").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      await hardwareWalletSigner.signContractWithLedger(contractHash);
    });
  });

  // BotÃ³n genÃ©rico para detectar hardware wallet disponible
  document.querySelectorAll(".sign-contract-hardware").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      await hardwareWalletSigner.detectAndSign(contractHash);
    });
  });
});

export default hardwareWalletSigner;
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): agrega funciÃ³n para firmar contratos usando Trezor y Ledger"
```

## ðŸ“Œ Commit 40.3: Crear Endpoint para Verificar Firmas de Hardware Wallets
ðŸ”¹ **Mensaje de commit:**
```
feat(hardware-wallets): agrega endpoint para firmar contratos con hardware wallets y verificar autenticidad
```

ðŸ”¹ **Contenido del commit:**

### Modificar ContractsController para Integrar Firma con Hardware Wallets
```ruby
class ContractsController < ApplicationController
  def sign_hardware_wallet
    contract_hash = params[:contract_hash]
    user_address = params[:user_address]
    signature = params[:signature]
    wallet_type = params[:wallet_type] # 'trezor' o 'ledger'
    
    # Verificar firma segÃºn el tipo de wallet
    valid = case wallet_type
            when 'trezor'
              SmartContractService.verify_trezor_signature(contract_hash, user_address, signature)
            when 'ledger'
              SmartContractService.verify_ledger_signature(contract_hash, user_address, signature)
            else
              false
            end
    
    if valid
      # Registrar la firma en la base de datos
      contract_signature = ContractSignature.create!(
        contract_hash: contract_hash,
        user_address: user_address,
        signature: signature,
        wallet_type: wallet_type,
        signed_at: Time.current
      )
      
      # Enviar transacciÃ³n a la blockchain
      tx_hash = SmartContractService.sign_contract(
        user_address, 
        contract_hash, 
        signature,
        wallet_type
      )
      
      # Enviar notificaciones
      notify_contract_signed(contract_hash, user_address, wallet_type)
      
      render json: { 
        message: "Contrato firmado en Blockchain con #{wallet_type.capitalize}", 
        transaction_hash: tx_hash,
        signature_id: contract_signature.id
      }
    else
      render json: { error: "Firma invÃ¡lida" }, status: :unauthorized
    end
  rescue => e
    Rails.logger.error "Error procesando firma de hardware wallet: #{e.message}"
    render json: { error: "Error interno del servidor" }, status: :internal_server_error
  end

  private

  def notify_contract_signed(contract_hash, user_address, wallet_type)
    # Notificar vÃ­a WebSockets
    ActionCable.server.broadcast("contract_#{contract_hash}", {
      event: "signature_added",
      user_address: user_address,
      wallet_type: wallet_type,
      timestamp: Time.current.iso8601
    })
    
    # Enviar notificaciÃ³n por email/SMS si estÃ¡ configurado
    user = User.find_by(wallet_address: user_address)
    if user
      UserNotification.with(
        message: "Contrato #{contract_hash} firmado con #{wallet_type.capitalize}"
      ).deliver(user)
    end
  end
end
```

### Agregar Ruta en config/routes.rb
```ruby
Rails.application.routes.draw do
  post "/contracts/sign_hardware_wallet", to: "contracts#sign_hardware_wallet"
end
```

### Crear Modelo ContractSignature
```ruby
class ContractSignature < ApplicationRecord
  validates :contract_hash, :user_address, :signature, :wallet_type, presence: true
  validates :wallet_type, inclusion: { in: %w[trezor ledger] }
  
  scope :by_contract, ->(hash) { where(contract_hash: hash) }
  scope :by_wallet_type, ->(type) { where(wallet_type: type) }
  
  def display_wallet_type
    wallet_type.capitalize
  end
end
```

### MigraciÃ³n para ContractSignature
```ruby
class CreateContractSignatures < ActiveRecord::Migration[7.0]
  def change
    create_table :contract_signatures do |t|
      t.string :contract_hash, null: false, index: true
      t.string :user_address, null: false
      t.text :signature, null: false
      t.string :wallet_type, null: false
      t.datetime :signed_at, null: false
      t.timestamps
    end
    
    add_index :contract_signatures, [:contract_hash, :user_address], unique: true
    add_index :contract_signatures, :wallet_type
  end
end
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): agrega endpoint para firmar contratos con hardware wallets y verificar autenticidad"
```

## ðŸ“Œ Commit 40.4: Modificar Servicio de Smart Contracts para Verificar Firmas de Hardware Wallets
ðŸ”¹ **Mensaje de commit:**
```
feat(hardware-wallets): agrega verificaciÃ³n de firmas con Trezor y Ledger en el servicio de Smart Contracts
```

ðŸ”¹ **Contenido del commit:**

### Modificar SmartContractService en app/services/smart_contract_service.rb
```ruby
require "web3"
require "eth"

class SmartContractService
  INFURA_URL = Rails.application.credentials.dig(:ethereum, :infura_url)
  CONTRACT_ADDRESS = Rails.application.credentials.dig(:ethereum, :contract_address)
  
  def self.sign_contract(user_address, contract_hash, signature, wallet_type = nil)
    web3 = Web3::Eth::Rpc.new(host: INFURA_URL, port: 443, connect_options: { use_ssl: true })
    contract_abi = JSON.parse(File.read(Rails.root.join("config/contract_abi.json")))
    contract = web3.eth.contract(abi: contract_abi).at(CONTRACT_ADDRESS)
    
    # Incluir el tipo de wallet en los metadatos de la transacciÃ³n
    tx_data = {
      from: user_address,
      gas: 200_000,
      gasPrice: web3.eth.gas_price,
      data: contract.sign_contract.call_data(contract_hash, signature)
    }
    
    # Agregar metadatos del wallet si estÃ¡ disponible
    if wallet_type
      tx_data[:memo] = "Signed with #{wallet_type}"
    end
    
    tx = contract.transact_and_wait.signContract(contract_hash, signature, tx_data)
    tx.transaction_hash
  end
  
  def self.verify_trezor_signature(contract_hash, user_address, signature)
    begin
      web3 = Web3::Eth::Rpc.new(host: INFURA_URL, port: 443, connect_options: { use_ssl: true })
      
      # Verificar usando el mÃ©todo estÃ¡ndar de recuperaciÃ³n de direcciÃ³n
      recovered_address = web3.eth.personal.ec_recover(contract_hash, signature)
      recovered_address.downcase == user_address.downcase
    rescue => e
      Rails.logger.error "Error verificando firma Trezor: #{e.message}"
      false
    end
  end
  
  def self.verify_ledger_signature(contract_hash, user_address, signature)
    begin
      # Ledger usa un formato ligeramente diferente para las firmas
      # Verificar usando eth gem para mayor precisiÃ³n
      key = Eth::Key.new
      message_hash = Eth::Util.keccak256(contract_hash)
      
      # Parsear la firma de Ledger
      signature_bytes = [signature.gsub('0x', '')].pack('H*')
      r = signature_bytes[0..31]
      s = signature_bytes[32..63]
      v = signature_bytes[64]
      
      # Recuperar la direcciÃ³n pÃºblica
      recovered_key = Eth::Key.recover_compact(message_hash, signature_bytes)
      recovered_address = recovered_key.address
      
      recovered_address.downcase == user_address.downcase
    rescue => e
      Rails.logger.error "Error verificando firma Ledger: #{e.message}"
      false
    end
  end
  
  def self.get_contract_signatures(contract_hash)
    ContractSignature.by_contract(contract_hash).includes(:user)
  end
  
  def self.contract_fully_signed?(contract_hash, required_signatures = 2)
    signatures_count = ContractSignature.by_contract(contract_hash).count
    signatures_count >= required_signatures
  end
end
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(hardware-wallets): agrega verificaciÃ³n de firmas con Trezor y Ledger en el servicio de Smart Contracts"
```

## ðŸ“ ExplicaciÃ³n y CÃ³digo Generado

### Ejemplo de Firma de Contrato con Trezor
1. El usuario hace clic en "Firmar Contrato con Trezor".
2. Trezor Connect solicita la firma del contrato en el hardware wallet.
3. El usuario confirma la firma en su dispositivo.
4. El backend verifica la firma y la registra en la blockchain.

### Ejemplo de Firma de Contrato con Ledger
1. El usuario conecta su Ledger y hace clic en "Firmar Contrato con Ledger".
2. El sistema solicita la firma en el dispositivo Ledger.
3. El usuario confirma la transacciÃ³n en su Ledger.
4. La firma se verifica y se registra automÃ¡ticamente.

### Ejemplo de Uso en Rails Console
```ruby
# Verificar firma de Trezor
SmartContractService.verify_trezor_signature(
  "0xContratoHash", 
  "0xUserWallet", 
  "0xFirmaDigital"
)

# Verificar firma de Ledger
SmartContractService.verify_ledger_signature(
  "0xContratoHash", 
  "0xUserWallet", 
  "0xFirmaDigitalLedger"
)

# Obtener todas las firmas de un contrato
SmartContractService.get_contract_signatures("0xContratoHash")

# Verificar si un contrato estÃ¡ completamente firmado
SmartContractService.contract_fully_signed?("0xContratoHash", 3)
```

### Ejemplo de VerificaciÃ³n de Firma con Hardware Wallet
```bash
curl -X POST "http://localhost:3000/contracts/sign_hardware_wallet" \
  -H "Content-Type: application/json" \
  -d '{
    "contract_hash": "0xContratoHash",
    "user_address": "0xUserWallet",
    "signature": "0xFirmaDigital",
    "wallet_type": "trezor"
  }'
```

### Respuesta Exitosa:
```json
{
  "message": "Contrato firmado en Blockchain con Trezor",
  "transaction_hash": "0xabc123...",
  "signature_id": 123
}
```

### Respuesta de Error:
```json
{
  "error": "Firma invÃ¡lida"
}
```

## ðŸ”§ ConfiguraciÃ³n y Deployment

### Variables de Entorno Requeridas
```bash
# Ethereum Configuration
ETHEREUM_INFURA_URL=https://mainnet.infura.io/v3/YOUR_PROJECT_ID
ETHEREUM_CONTRACT_ADDRESS=0xYourContractAddress

# Security
WEB3_PRIVATE_KEY=your_private_key_for_contract_deployment
```

### ConfiguraciÃ³n de ProducciÃ³n
```ruby
# En config/credentials.yml.enc
rails credentials:edit

# Agregar:
ethereum:
  infura_url: https://mainnet.infura.io/v3/YOUR_PROJECT_ID
  contract_address: 0xYourContractAddress
  private_key: your_private_key
```

### VerificaciÃ³n de Hardware Wallets en Desarrollo
```javascript
// En la consola del navegador
// Verificar Trezor
TrezorConnect.getFeatures().then(result => console.log(result));

// Verificar Ledger (requiere conexiÃ³n USB)
LedgerWallet.connect().then(connected => console.log('Ledger connected:', connected));
```