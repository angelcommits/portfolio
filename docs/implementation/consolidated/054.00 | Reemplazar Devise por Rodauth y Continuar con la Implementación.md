# ‚úÖ Paso 54: Reemplazar Devise por Rodauth y Continuar con la Implementaci√≥n

> **ARCHIVO CONSOLIDADO** - Combina migraci√≥n a Rodauth con Social Login para m√°xima flexibilidad de autenticaci√≥n

Ahora vamos a reemplazar Devise por Rodauth, manteniendo todas las funcionalidades de autenticaci√≥n (Web3 Sign-In, Smart Contract Wallets, Passkeys, Social Login).
‚úÖ Rodauth (Authentication for Roda/Rails) ‚Üí Autenticaci√≥n sin dependencias m√°gicas.
‚úÖ SQLite en desarrollo y test, PostgreSQL en staging y producci√≥n ‚Üí Configuraci√≥n optimizada por entorno.
‚úÖ Compatibilidad con Web3 ID (Ethereum Sign-In) ‚Üí Autenticaci√≥n sin contrase√±a.
‚úÖ Passkeys (WebAuthn) + Smart Contract Wallets ‚Üí Para recuperaci√≥n de cuenta segura.
‚úÖ Social Login (Google, Twitter, Discord) ‚Üí Recuperaci√≥n de cuenta alternativa.
‚úÖ Turbo Streams + Stimulus.js ‚Üí Para UI interactiva y sin recargas.

## ‚ö†Ô∏è Antes de Comenzar: Configuraci√≥n de Base de Datos

Rodauth usa Sequel como ORM. Por defecto, soporta SQLite, PostgreSQL y MySQL.
‚úÖ **Desarrollo y Test**: SQLite (r√°pido, sin configuraci√≥n)
‚úÖ **Staging y Producci√≥n**: PostgreSQL (robusto, escalable)

## üìå Commit 54.1: Instalar Rodauth y Configurar Base de Datos
üîπ **Mensaje de commit:**
```
feat(auth): instala Rodauth y configura Sequel con SQLite en desarrollo y PostgreSQL en producci√≥n
```

üîπ **Contenido del commit:**

### Instalar Rodauth y Dependencias
```bash
# A√±adir gems necesarias
bundle add roda rodauth-sequel sequel sqlite3 pg
bundle add omniauth-google-oauth2 omniauth-twitter omniauth-discord
bundle add webauthn # Para Passkeys
```

### Configurar Base de Datos en config/database.yml
```yaml
default: &default
  adapter: <%= ENV.fetch("DB_ADAPTER") { "sqlite3" } %>
  encoding: utf8
  pool: 5
  timeout: 5000

development:
  <<: *default
  database: db/development.sqlite3

test:
  <<: *default
  database: db/test.sqlite3

staging:
  <<: *default
  adapter: postgresql
  database: portfolio_staging
  username: portfolio_user
  password: <%= ENV['DATABASE_PASSWORD'] %>
  host: <%= ENV.fetch('DATABASE_HOST', 'localhost') %>
  port: <%= ENV.fetch('DATABASE_PORT', 5432) %>

production:
  <<: *default
  adapter: postgresql
  database: portfolio_production
  username: portfolio_user
  password: <%= ENV['DATABASE_PASSWORD'] %>
  host: <%= ENV.fetch('DATABASE_HOST', 'localhost') %>
  port: <%= ENV.fetch('DATABASE_PORT', 5432) %>
```

### Configurar Variables de Entorno
```bash
# .env.development
DB_ADAPTER=sqlite3
DATABASE_URL=sqlite://db/development.sqlite3

# .env.staging
DB_ADAPTER=postgresql
DATABASE_URL=postgresql://portfolio_user:password@localhost:5432/portfolio_staging
DATABASE_PASSWORD=your_staging_password

# .env.production
DB_ADAPTER=postgresql
DATABASE_URL=postgresql://portfolio_user:password@host:5432/portfolio_production
DATABASE_PASSWORD=your_production_password
```

üîπ **A√±adir archivos al commit:**
```bash
git add .
git commit -m "feat(auth): instala Rodauth y configura Sequel con SQLite en desarrollo y PostgreSQL en producci√≥n"
```

## üìå Commit 54.2: Configurar Rodauth en Rails
üîπ **Mensaje de commit:**
```
feat(auth): configura Rodauth como sistema de autenticaci√≥n principal en Rails
```

üîπ **Contenido del commit:**

### Generar Configuraci√≥n de Rodauth
```bash
rails generate rodauth:install
```

### Modificar config/initializers/rodauth.rb
```ruby
require "roda"
require "rodauth"
require "sequel"

# Configuraci√≥n de la base de datos seg√∫n el entorno
DB = Sequel.connect(
  ENV.fetch("DATABASE_URL") do
    case Rails.env
    when "development", "test"
      "sqlite://#{Rails.root}/db/#{Rails.env}.sqlite3"
    when "staging"
      "postgresql://#{ENV.fetch('DATABASE_URL', 'localhost:5432/portfolio_staging')}"
    when "production"
      "postgresql://#{ENV.fetch('DATABASE_URL', 'localhost:5432/portfolio_production')}"
    end
  end
)

class RodauthMain < Rodauth::Auth
  configure do
    # Habilitar funcionalidades b√°sicas
    enable :login, :logout, :create_account, :reset_password, :change_password
    enable :verify_account, :remember, :lockout
    
    # Habilitar funcionalidades avanzadas
    enable :otp, :webauthn, :jwt, :active_sessions
    
    # Configuraci√≥n de la base de datos
    db DB
    accounts_table :accounts
    
    # Configuraci√≥n de columnas
    account_password_hash_column :password_hash
    login_column :email
    
    # Configuraci√≥n para Web3
    account_id_column :id
    
    # Configuraci√≥n de sesi√≥n
    session_key :account_id
    
    # Configuraci√≥n de URL
    login_route "login"
    logout_route "logout"
    create_account_route "register"
    
    # Configuraci√≥n de vistas
    views_layout { |title| "<!DOCTYPE html><html><head><title>#{title}</title></head><body>#{yield}</body></html>" }
    
    # Configuraci√≥n de redirecciones
    login_redirect "/dashboard"
    logout_redirect "/"
    
    # Configuraci√≥n de validaciones
    require_password_confirmation? false
    
    # Hooks para integraci√≥n con Rails
    after_login do
      Rails.logger.info "Usuario #{account[:email]} inici√≥ sesi√≥n"
    end
    
    after_logout do
      Rails.logger.info "Usuario cerr√≥ sesi√≥n"
    end
  end
end

class RodauthApp < Roda
  plugin :middleware
  plugin :json
  
  route do |r|
    r.rodauth
    
    # Manejar rutas de API JSON
    r.is "api", "auth" do
      r.post "login" do
        # L√≥gica de login API
      end
      
      r.post "web3_login" do
        # L√≥gica de Web3 Sign-In
      end
    end
  end
end
```

### Crear Migraciones de Rodauth
```bash
# Generar migraciones para las tablas de Rodauth
rails generate migration CreateRodauthTables
```

### Modificar la migraci√≥n db/migrate/xxx_create_rodauth_tables.rb
```ruby
class CreateRodauthTables < ActiveRecord::Migration[7.0]
  def up
    # Tabla principal de cuentas
    create_table :accounts, id: :primary_key do |t|
      t.string :email, null: false
      t.string :password_hash
      t.string :wallet_address, index: { unique: true }
      t.integer :status, null: false, default: 1
      t.timestamps null: false
    end
    
    add_index :accounts, :email, unique: true
    add_index :accounts, :wallet_address, unique: true
    
    # Tabla para verificaci√≥n de cuenta
    create_table :account_verification_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.datetime :requested_at, null: false, default: -> { "CURRENT_TIMESTAMP" }
      t.datetime :email_last_sent, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end
    
    # Tabla para reset de contrase√±a
    create_table :account_password_reset_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.datetime :deadline, null: false
      t.datetime :email_last_sent, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end
    
    # Tabla para Remember Me
    create_table :account_remember_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.datetime :deadline, null: false
    end
    
    # Tabla para lockout de cuentas
    create_table :account_login_failures do |t|
      t.foreign_key :accounts, column: :id
      t.integer :number, null: false, default: 1
    end
    
    # Tabla para OTP (2FA)
    create_table :account_otp_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :key, null: false
      t.integer :num_failures, null: false, default: 0
      t.datetime :last_use, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end
    
    # Tabla para WebAuthn (Passkeys)
    create_table :account_webauthn_user_ids do |t|
      t.foreign_key :accounts, column: :id
      t.string :webauthn_id, null: false
    end
    
    create_table :account_webauthn_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :webauthn_id, null: false
      t.string :public_key, null: false
      t.integer :sign_count, null: false
      t.datetime :last_use, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end
    
    # Tabla para sesiones activas
    create_table :account_active_session_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :session_id, null: false
      t.datetime :created_at, null: false, default: -> { "CURRENT_TIMESTAMP" }
      t.datetime :last_use, null: false, default: -> { "CURRENT_TIMESTAMP" }
    end
    
    # Tabla para identidades sociales
    create_table :account_identities do |t|
      t.foreign_key :accounts, column: :id
      t.string :provider, null: false
      t.string :uid, null: false
      t.json :info
      t.timestamps null: false
    end
    
    add_index :account_identities, [:provider, :uid], unique: true
    
    # Tabla para Web3 Sign-In
    create_table :account_web3_keys do |t|
      t.foreign_key :accounts, column: :id
      t.string :wallet_address, null: false
      t.string :signature
      t.string :nonce
      t.datetime :nonce_expires_at
      t.datetime :last_sign_in
      t.timestamps null: false
    end
    
    add_index :account_web3_keys, :wallet_address, unique: true
  end
  
  def down
    drop_table :account_web3_keys
    drop_table :account_identities
    drop_table :account_active_session_keys
    drop_table :account_webauthn_keys
    drop_table :account_webauthn_user_ids
    drop_table :account_otp_keys
    drop_table :account_login_failures
    drop_table :account_remember_keys
    drop_table :account_password_reset_keys
    drop_table :account_verification_keys
    drop_table :accounts
  end
end
```

üîπ **A√±adir archivos al commit:**
```bash
git add .
git commit -m "feat(auth): configura Rodauth como sistema de autenticaci√≥n principal en Rails"
```

## üìå Commit 54.3: Integrar Social Login con Rodauth
üîπ **Mensaje de commit:**
```
feat(auth): agrega soporte para Social Login (Google, Twitter, Discord) con Rodauth
```

üîπ **Contenido del commit:**

### Configurar OmniAuth en config/initializers/omniauth.rb
```ruby
Rails.application.config.middleware.use OmniAuth::Builder do
  provider :google_oauth2,
           Rails.application.credentials.dig(:omniauth, :google, :client_id),
           Rails.application.credentials.dig(:omniauth, :google, :client_secret),
           {
             scope: 'email,profile',
             prompt: 'select_account',
             image_aspect_ratio: 'square',
             image_size: 50
           }
           
  provider :twitter,
           Rails.application.credentials.dig(:omniauth, :twitter, :api_key),
           Rails.application.credentials.dig(:omniauth, :twitter, :api_secret)
           
  provider :discord,
           Rails.application.credentials.dig(:omniauth, :discord, :client_id),
           Rails.application.credentials.dig(:omniauth, :discord, :client_secret),
           { scope: 'identify email' }
end
```

### Crear Controlador para Social Login
```ruby
# app/controllers/auth/social_logins_controller.rb
class Auth::SocialLoginsController < ApplicationController
  def callback
    auth = request.env["omniauth.auth"]
    
    # Buscar o crear cuenta basada en la identidad social
    account = find_or_create_account_from_omniauth(auth)
    
    if account
      # Iniciar sesi√≥n usando Rodauth
      rodauth.login_session(account[:id])
      
      redirect_to rodauth.login_redirect, 
                  notice: "Autenticaci√≥n exitosa con #{auth.provider.capitalize}"
    else
      redirect_to rodauth.login_path, 
                  alert: "Error en la autenticaci√≥n con #{auth.provider.capitalize}"
    end
  end
  
  def failure
    redirect_to rodauth.login_path, 
                alert: "Error en la autenticaci√≥n: #{params[:message]}"
  end
  
  private
  
  def find_or_create_account_from_omniauth(auth)
    # Buscar identidad existente
    identity_info = {
      provider: auth.provider,
      uid: auth.uid,
      info: {
        email: auth.info.email,
        name: auth.info.name,
        image: auth.info.image
      }
    }
    
    # Usar Sequel para manejar la base de datos
    account = nil
    
    DB.transaction do
      # Buscar identidad existente
      existing_identity = DB[:account_identities]
        .where(provider: auth.provider, uid: auth.uid)
        .first
      
      if existing_identity
        # Cuenta existente
        account = DB[:accounts].where(id: existing_identity[:id]).first
      else
        # Buscar por email si no existe la identidad
        account = DB[:accounts].where(email: auth.info.email).first
        
        unless account
          # Crear nueva cuenta
          account_id = DB[:accounts].insert(
            email: auth.info.email,
            status: 2, # Verificada (viene de proveedor social)
            created_at: Time.current,
            updated_at: Time.current
          )
          account = DB[:accounts].where(id: account_id).first
        end
        
        # Crear la identidad social
        DB[:account_identities].insert(
          id: account[:id],
          provider: auth.provider,
          uid: auth.uid,
          info: identity_info[:info].to_json,
          created_at: Time.current,
          updated_at: Time.current
        )
      end
    end
    
    account
  rescue => e
    Rails.logger.error "Error en social login: #{e.message}"
    nil
  end
end
```

### Agregar Rutas para Social Login
```ruby
# config/routes.rb
Rails.application.routes.draw do
  # Rutas de OmniAuth
  get "/auth/:provider/callback", to: "auth/social_logins#callback"
  get "/auth/failure", to: "auth/social_logins#failure"
  
  # Montar Rodauth
  mount RodauthApp, at: "/auth"
end
```

üîπ **A√±adir archivos al commit:**
```bash
git add .
git commit -m "feat(auth): agrega soporte para Social Login (Google, Twitter, Discord) con Rodauth"
```

## üìå Commit 54.4: Integrar Web3 Sign-In con Rodauth
üîπ **Mensaje de commit:**
```
feat(auth): agrega soporte para Web3 Sign-In (Ethereum) con Rodauth
```

üîπ **Contenido del commit:**

### Crear Controlador para Web3 Authentication
```ruby
# app/controllers/auth/web3_controller.rb
class Auth::Web3Controller < ApplicationController
  def generate_nonce
    wallet_address = params[:wallet_address]&.downcase
    
    if wallet_address.blank? || !valid_ethereum_address?(wallet_address)
      render json: { error: "Direcci√≥n de wallet inv√°lida" }, status: :bad_request
      return
    end
    
    nonce = SecureRandom.hex(16)
    expires_at = 15.minutes.from_now
    
    # Guardar o actualizar el nonce para esta wallet
    DB.transaction do
      existing = DB[:account_web3_keys].where(wallet_address: wallet_address).first
      
      if existing
        DB[:account_web3_keys]
          .where(wallet_address: wallet_address)
          .update(
            nonce: nonce,
            nonce_expires_at: expires_at,
            updated_at: Time.current
          )
      else
        DB[:account_web3_keys].insert(
          wallet_address: wallet_address,
          nonce: nonce,
          nonce_expires_at: expires_at,
          created_at: Time.current,
          updated_at: Time.current
        )
      end
    end
    
    render json: {
      nonce: nonce,
      message: build_sign_message(wallet_address, nonce),
      expires_at: expires_at.iso8601
    }
  end
  
  def verify_signature
    wallet_address = params[:wallet_address]&.downcase
    signature = params[:signature]
    
    if wallet_address.blank? || signature.blank?
      render json: { error: "Par√°metros faltantes" }, status: :bad_request
      return
    end
    
    web3_key = DB[:account_web3_keys].where(wallet_address: wallet_address).first
    
    unless web3_key
      render json: { error: "Nonce no encontrado" }, status: :not_found
      return
    end
    
    if web3_key[:nonce_expires_at] < Time.current
      render json: { error: "Nonce expirado" }, status: :unauthorized
      return
    end
    
    message = build_sign_message(wallet_address, web3_key[:nonce])
    
    if verify_ethereum_signature(message, signature, wallet_address)
      # Firma v√°lida, encontrar o crear cuenta
      account = find_or_create_account_from_wallet(wallet_address)
      
      # Actualizar la clave Web3
      DB[:account_web3_keys]
        .where(wallet_address: wallet_address)
        .update(
          signature: signature,
          last_sign_in: Time.current,
          updated_at: Time.current
        )
      
      # Iniciar sesi√≥n usando Rodauth
      rodauth.login_session(account[:id])
      
      render json: {
        success: true,
        account: {
          id: account[:id],
          email: account[:email],
          wallet_address: wallet_address
        },
        redirect_url: rodauth.login_redirect
      }
    else
      render json: { error: "Firma inv√°lida" }, status: :unauthorized
    end
  end
  
  private
  
  def valid_ethereum_address?(address)
    address.match?(/\A0x[a-fA-F0-9]{40}\z/)
  end
  
  def build_sign_message(wallet_address, nonce)
    "Portfolio dApp Sign-In\n\n" \
    "Wallet: #{wallet_address}\n" \
    "Nonce: #{nonce}\n" \
    "Timestamp: #{Time.current.iso8601}"
  end
  
  def verify_ethereum_signature(message, signature, expected_address)
    begin
      # Usar la gema eth para verificar la firma
      require 'eth'
      
      # Crear el hash del mensaje como lo hace MetaMask
      message_hash = Eth::Util.keccak256("\x19Ethereum Signed Message:\n#{message.length}#{message}")
      
      # Recuperar la direcci√≥n p√∫blica desde la firma
      signature_bytes = [signature.gsub('0x', '')].pack('H*')
      recovered_key = Eth::Key.recover_compact(message_hash, signature_bytes)
      recovered_address = recovered_key.address.downcase
      
      recovered_address == expected_address
    rescue => e
      Rails.logger.error "Error verificando firma Web3: #{e.message}"
      false
    end
  end
  
  def find_or_create_account_from_wallet(wallet_address)
    # Buscar cuenta existente por wallet
    account = DB[:accounts].where(wallet_address: wallet_address).first
    
    unless account
      # Crear nueva cuenta
      account_id = DB[:accounts].insert(
        email: "#{wallet_address}@web3.local", # Email temporal
        wallet_address: wallet_address,
        status: 2, # Verificada (Web3)
        created_at: Time.current,
        updated_at: Time.current
      )
      account = DB[:accounts].where(id: account_id).first
    end
    
    account
  end
end
```

### Agregar Rutas para Web3
```ruby
# config/routes.rb
Rails.application.routes.draw do
  namespace :auth do
    # Web3 Sign-In
    post "web3/generate_nonce", to: "web3#generate_nonce"
    post "web3/verify_signature", to: "web3#verify_signature"
    
    # Social Login
    get ":provider/callback", to: "social_logins#callback"
    get "failure", to: "social_logins#failure"
  end
  
  # Montar Rodauth
  mount RodauthApp, at: "/auth"
end
```

üîπ **A√±adir archivos al commit:**
```bash
git add .
git commit -m "feat(auth): agrega soporte para Web3 Sign-In (Ethereum) con Rodauth"
```

## üìù Explicaci√≥n y C√≥digo Generado

### Ejemplo de Uso en Rails Console
```ruby
# Verificar configuraci√≥n de base de datos
DB.test_connection

# Crear una cuenta manualmente
account_id = DB[:accounts].insert(
  email: "user@example.com",
  password_hash: BCrypt::Password.create("password123"),
  status: 2,
  created_at: Time.current,
  updated_at: Time.current
)

# Verificar cuentas
DB[:accounts].all

# Verificar identidades sociales
DB[:account_identities].all
```

### Ejemplo de Social Login desde la UI
```html
<!-- app/views/auth/login.html.erb -->
<div class="social-login-buttons">
  <a href="/auth/google_oauth2" class="btn btn-google">
    Iniciar sesi√≥n con Google
  </a>
  <a href="/auth/twitter" class="btn btn-twitter">
    Iniciar sesi√≥n con Twitter
  </a>
  <a href="/auth/discord" class="btn btn-discord">
    Iniciar sesi√≥n con Discord
  </a>
</div>

<div class="web3-login">
  <button id="web3-sign-in" class="btn btn-web3">
    Conectar Wallet
  </button>
</div>
```

### Ejemplo de Web3 Sign-In JavaScript
```javascript
// app/javascript/packs/web3_auth.js
const connectWallet = async () => {
  if (typeof window.ethereum !== 'undefined') {
    try {
      // Solicitar acceso a la wallet
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts'
      });
      
      const walletAddress = accounts[0];
      
      // Generar nonce
      const nonceResponse = await fetch('/auth/web3/generate_nonce', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({ wallet_address: walletAddress })
      });
      
      const nonceData = await nonceResponse.json();
      
      // Firmar mensaje
      const signature = await window.ethereum.request({
        method: 'personal_sign',
        params: [nonceData.message, walletAddress]
      });
      
      // Verificar firma
      const verifyResponse = await fetch('/auth/web3/verify_signature', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({
          wallet_address: walletAddress,
          signature: signature
        })
      });
      
      const result = await verifyResponse.json();
      
      if (result.success) {
        window.location.href = result.redirect_url;
      } else {
        alert('Error en la autenticaci√≥n: ' + result.error);
      }
    } catch (error) {
      console.error('Error conectando wallet:', error);
      alert('Error conectando con la wallet');
    }
  } else {
    alert('Por favor instala MetaMask');
  }
};

document.getElementById('web3-sign-in')?.addEventListener('click', connectWallet);
```

## üîß Configuraci√≥n de Producci√≥n

### Variables de Entorno Requeridas
```bash
# Database Configuration
DATABASE_URL=postgresql://user:password@host:5432/database
DATABASE_PASSWORD=your_secure_password

# OAuth Credentials
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
TWITTER_API_KEY=your_twitter_api_key
TWITTER_API_SECRET=your_twitter_api_secret
DISCORD_CLIENT_ID=your_discord_client_id
DISCORD_CLIENT_SECRET=your_discord_client_secret

# Session Security
SECRET_KEY_BASE=your_secret_key_base
RODAUTH_JWT_SECRET=your_jwt_secret
```

### Migraci√≥n de Devise a Rodauth
```ruby
# Script de migraci√≥n
class MigrateFromDevise
  def self.migrate_users
    # Migrar usuarios existentes de Devise a Rodauth
    User.find_each do |user|
      account_id = DB[:accounts].insert(
        email: user.email,
        password_hash: user.encrypted_password,
        wallet_address: user.wallet_address,
        status: user.confirmed? ? 2 : 1,
        created_at: user.created_at,
        updated_at: user.updated_at
      )
      
      puts "Migrated user #{user.email} -> account #{account_id}"
    end
  end
end
```