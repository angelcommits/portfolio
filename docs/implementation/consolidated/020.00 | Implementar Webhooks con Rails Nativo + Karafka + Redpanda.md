# âœ… Paso 20: Implementar Webhooks con Rails Nativo + Karafka + Redpanda

> **ARCHIVO CONSOLIDADO** - Combina Kafka con Redpanda para mÃ¡xima compatibilidad y rendimiento

Ahora configuraremos Webhooks en Rails para recibir eventos externos y usaremos Karafka con Redpanda para procesarlos asÃ­ncronamente.
âœ… Rails Webhooks â†’ Endpoint para recibir eventos externos.
âœ… Karafka â†’ Cliente de Kafka para procesar los eventos de los webhooks.
âœ… Redpanda â†’ Reemplazo ligero de Kafka sin dependencias en Zookeeper.
âœ… Procesamiento en segundo plano â†’ Para evitar bloquear la aplicaciÃ³n principal.

## ðŸ“Œ Commit 20.1: Instalar Karafka y Configurar Redpanda
ðŸ”¹ **Mensaje de commit:**
```
feat(webhooks): instala Karafka y configura Redpanda para procesamiento de eventos asÃ­ncronos
```

ðŸ”¹ **Contenido del commit:**
```bash
# AÃ±adir Karafka al Gemfile
echo "gem 'karafka', '~> 2.2'" >> Gemfile
# Instalar la gema
bundle install
# Inicializar Karafka
bundle exec karafka install
# Configurar Redpanda en Docker
mkdir -p infra/redpanda
touch infra/redpanda/docker-compose.yml
```

### Definir infra/redpanda/docker-compose.yml
```yaml
version: '3.8'
services:
  redpanda:
    image: redpandadata/redpanda:latest
    container_name: redpanda
    ports:
      - "9092:9092"
      - "9644:9644"
      - "8082:8082"
    command:
      - redpanda start
      - --smp 1
      - --memory 1G
      - --reserve-memory 0M
      - --overprovisioned
      - --node-id 0
      - --check=false
      - --kafka-addr PLAINTEXT://0.0.0.0:29092,OUTSIDE://0.0.0.0:9092
      - --advertise-kafka-addr PLAINTEXT://redpanda:29092,OUTSIDE://localhost:9092
      - --pandaproxy-addr 0.0.0.0:8082
      - --advertise-pandaproxy-addr localhost:8082
    environment:
      REDPANDA_ENVIRONMENT: development
    volumes:
      - redpanda_data:/var/lib/redpanda/data

volumes:
  redpanda_data:
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(webhooks): instala Karafka y configura Redpanda para procesamiento de eventos asÃ­ncronos"
```

## ðŸ“Œ Commit 20.2: Configurar Endpoint para Recibir Webhooks
ðŸ”¹ **Mensaje de commit:**
```
feat(webhooks): agrega endpoint en WebhooksController para recibir eventos externos
```

ðŸ”¹ **Contenido del commit:**

### Crear WebhooksController
```ruby
class WebhooksController < ApplicationController
  skip_before_action :verify_authenticity_token

  def receive
    event_type = request.headers["X-Event-Type"]
    payload = request.body.read
    
    # Enviar a Kafka/Redpanda para procesamiento asÃ­ncrono
    Karafka.producer.produce_async(
      topic: "webhooks",
      payload: payload,
      key: event_type,
      headers: {
        "content-type" => request.content_type,
        "user-agent" => request.user_agent,
        "timestamp" => Time.current.to_i.to_s
      }
    )
    
    head :ok
  rescue => e
    Rails.logger.error "Webhook processing error: #{e.message}"
    head :unprocessable_entity
  end
end
```

### Definir Ruta en config/routes.rb
```ruby
Rails.application.routes.draw do
  post "/webhooks", to: "webhooks#receive"
  post "/webhooks/:provider", to: "webhooks#receive" # Para webhooks especÃ­ficos
end
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(webhooks): agrega endpoint en WebhooksController para recibir eventos externos"
```

## ðŸ“Œ Commit 20.3: Configurar Karafka para Consumir Webhooks
ðŸ”¹ **Mensaje de commit:**
```
feat(webhooks): agrega consumidor de eventos para procesar webhooks con Karafka
```

ðŸ”¹ **Contenido del commit:**

### Definir Consumidor en app/consumers/webhook_consumer.rb
```ruby
class WebhookConsumer < Karafka::BaseConsumer
  def consume
    messages.each do |message|
      event_type = message.key
      payload = JSON.parse(message.payload)
      headers = message.headers
      
      Rails.logger.info("Procesando webhook: #{event_type}")
      
      case event_type
      when "user.created"
        handle_user_created(payload)
      when "order.completed"
        handle_order_completed(payload)
      when "payment.succeeded"
        handle_payment_succeeded(payload)
      when "gnosis.transaction.executed"
        handle_gnosis_transaction(payload)
      else
        Rails.logger.warn("Evento no reconocido: #{event_type}")
        handle_unknown_event(event_type, payload)
      end
    end
  end

  private

  def handle_user_created(payload)
    User.create!(
      email: payload["email"],
      name: payload["name"],
      external_id: payload["id"]
    )
    Rails.logger.info("Usuario creado: #{payload['email']}")
  end

  def handle_order_completed(payload)
    order = Order.find_by(external_id: payload["order_id"])
    order&.update(status: "completed", completed_at: Time.current)
    Rails.logger.info("Orden completada: #{payload['order_id']}")
  end

  def handle_payment_succeeded(payload)
    payment = Payment.find_by(external_id: payload["payment_id"])
    payment&.update(status: "succeeded", processed_at: Time.current)
    
    # Enviar notificaciÃ³n
    UserNotification.with(
      message: "Pago procesado exitosamente: #{payload['amount']}"
    ).deliver(payment.user)
  end

  def handle_gnosis_transaction(payload)
    transaction_hash = payload["transaction_hash"]
    safe_address = payload["safe_address"]
    
    # Actualizar estado de la transacciÃ³n multisig
    multisig_tx = MultisigTransaction.find_by(
      transaction_hash: transaction_hash,
      safe_address: safe_address
    )
    
    multisig_tx&.update(status: "executed", executed_at: Time.current)
    
    # Notificar a todos los firmantes
    notify_multisig_execution(multisig_tx) if multisig_tx
  end

  def handle_unknown_event(event_type, payload)
    # Guardar eventos desconocidos para anÃ¡lisis posterior
    UnknownWebhookEvent.create!(
      event_type: event_type,
      payload: payload,
      received_at: Time.current
    )
  end

  def notify_multisig_execution(multisig_tx)
    multisig_tx.signers.each do |signer|
      UserNotification.with(
        message: "TransacciÃ³n multisig ejecutada: #{multisig_tx.transaction_hash}"
      ).deliver(signer)
    end
  end
end
```

### Configurar Karafka en karafka.rb
```ruby
class KarafkaApp < Karafka::App
  setup do |config|
    config.kafka = {
      'bootstrap.servers': ENV.fetch('KAFKA_BROKERS', 'localhost:9092'),
      'session.timeout.ms': 6000,
      'auto.offset.reset': 'earliest'
    }
    config.client_id = 'portfolio-webhooks'
  end

  consumer_group :webhooks do
    topic :webhooks do
      consumer WebhookConsumer
    end
  end
end
```

ðŸ”¹ **AÃ±adir archivos al commit:**
```bash
git add .
git commit -m "feat(webhooks): agrega consumidor de eventos para procesar webhooks con Karafka"
```

## ðŸ“ ExplicaciÃ³n y CÃ³digo Generado

### Ejemplo de Uso en Rails Console
```ruby
# Enviar un evento manualmente
Karafka.producer.produce_async(
  topic: "webhooks",
  payload: { email: "test@example.com", name: "Test User" }.to_json,
  key: "user.created"
)
```

### Ejemplo de RecepciÃ³n de Webhook en API
```bash
curl -X POST "http://localhost:3000/webhooks" \
  -H "X-Event-Type: user.created" \
  -H "Content-Type: application/json" \
  -d '{ "email": "newuser@example.com", "name": "New User" }'
```

### Ejemplo de Procesamiento de Webhooks en Karafka
```bash
# Iniciar el procesador de eventos
bundle exec karafka server

# En otro terminal, iniciar Redpanda
cd infra/redpanda && docker-compose up -d
```

### Monitoreo y Debugging
```ruby
# En Rails Console - Verificar mensajes en cola
Karafka::Admin.cluster_info

# Verificar Ãºltimos eventos procesados
UnknownWebhookEvent.recent.limit(10)

# EstadÃ­sticas de procesamiento
WebhookConsumer.processed_messages_count
```

## ðŸ”§ ConfiguraciÃ³n de ProducciÃ³n

### Variables de Entorno
```bash
# Kafka/Redpanda Configuration
KAFKA_BROKERS=redpanda-cluster:9092
KAFKA_SASL_USERNAME=your_username
KAFKA_SASL_PASSWORD=your_password

# Webhook Security
WEBHOOK_SECRET_TOKEN=your_secret_token
```

### Seguridad de Webhooks
```ruby
# En WebhooksController, agregar verificaciÃ³n de firma
def verify_webhook_signature
  signature = request.headers['X-Webhook-Signature']
  payload = request.body.read
  expected = OpenSSL::HMAC.hexdigest('SHA256', webhook_secret, payload)
  
  unless Rack::Utils.secure_compare(signature, "sha256=#{expected}")
    head :unauthorized
    return false
  end
  true
end

private

def webhook_secret
  Rails.application.credentials.webhook_secret_token
end
```