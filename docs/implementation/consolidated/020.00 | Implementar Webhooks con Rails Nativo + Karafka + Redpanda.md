# ✅ Paso 20: Implementar Webhooks con Rails Nativo + Karafka + Redpanda

> **ARCHIVO CONSOLIDADO** - Combina Kafka con Redpanda para máxima compatibilidad y rendimiento

Ahora configuraremos Webhooks en Rails para recibir eventos externos y usaremos Karafka con Redpanda para procesarlos asíncronamente.
✅ Rails Webhooks → Endpoint para recibir eventos externos.
✅ Karafka → Cliente de Kafka para procesar los eventos de los webhooks.
✅ Redpanda → Reemplazo ligero de Kafka sin dependencias en Zookeeper.
✅ Procesamiento en segundo plano → Para evitar bloquear la aplicación principal.

## 📌 Commit 20.1: Instalar Karafka y Configurar Redpanda
🔹 **Mensaje de commit:**
```
feat(webhooks): instala Karafka y configura Redpanda para procesamiento de eventos asíncronos
```

🔹 **Contenido del commit:**
```bash
# Añadir Karafka al Gemfile
echo "gem 'karafka', '~> 2.2'" >> Gemfile
# Instalar la gema
bundle install
# Inicializar Karafka
bundle exec karafka install
# Configurar Redpanda en Docker
mkdir -p infra/redpanda
touch infra/redpanda/docker-compose.yml
```

### Definir infra/redpanda/docker-compose.yml
```yaml
version: '3.8'
services:
  redpanda:
    image: redpandadata/redpanda:latest
    container_name: redpanda
    ports:
      - "9092:9092"
      - "9644:9644"
      - "8082:8082"
    command:
      - redpanda start
      - --smp 1
      - --memory 1G
      - --reserve-memory 0M
      - --overprovisioned
      - --node-id 0
      - --check=false
      - --kafka-addr PLAINTEXT://0.0.0.0:29092,OUTSIDE://0.0.0.0:9092
      - --advertise-kafka-addr PLAINTEXT://redpanda:29092,OUTSIDE://localhost:9092
      - --pandaproxy-addr 0.0.0.0:8082
      - --advertise-pandaproxy-addr localhost:8082
    environment:
      REDPANDA_ENVIRONMENT: development
    volumes:
      - redpanda_data:/var/lib/redpanda/data

volumes:
  redpanda_data:
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(webhooks): instala Karafka y configura Redpanda para procesamiento de eventos asíncronos"
```

## 📌 Commit 20.2: Configurar Endpoint para Recibir Webhooks
🔹 **Mensaje de commit:**
```
feat(webhooks): agrega endpoint en WebhooksController para recibir eventos externos
```

🔹 **Contenido del commit:**

### Crear WebhooksController
```ruby
class WebhooksController < ApplicationController
  skip_before_action :verify_authenticity_token

  def receive
    event_type = request.headers["X-Event-Type"]
    payload = request.body.read
    
    # Enviar a Kafka/Redpanda para procesamiento asíncrono
    Karafka.producer.produce_async(
      topic: "webhooks",
      payload: payload,
      key: event_type,
      headers: {
        "content-type" => request.content_type,
        "user-agent" => request.user_agent,
        "timestamp" => Time.current.to_i.to_s
      }
    )
    
    head :ok
  rescue => e
    Rails.logger.error "Webhook processing error: #{e.message}"
    head :unprocessable_entity
  end
end
```

### Definir Ruta en config/routes.rb
```ruby
Rails.application.routes.draw do
  post "/webhooks", to: "webhooks#receive"
  post "/webhooks/:provider", to: "webhooks#receive" # Para webhooks específicos
end
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(webhooks): agrega endpoint en WebhooksController para recibir eventos externos"
```

## 📌 Commit 20.3: Configurar Karafka para Consumir Webhooks
🔹 **Mensaje de commit:**
```
feat(webhooks): agrega consumidor de eventos para procesar webhooks con Karafka
```

🔹 **Contenido del commit:**

### Definir Consumidor en app/consumers/webhook_consumer.rb
```ruby
class WebhookConsumer < Karafka::BaseConsumer
  def consume
    messages.each do |message|
      event_type = message.key
      payload = JSON.parse(message.payload)
      headers = message.headers
      
      Rails.logger.info("Procesando webhook: #{event_type}")
      
      case event_type
      when "user.created"
        handle_user_created(payload)
      when "order.completed"
        handle_order_completed(payload)
      when "payment.succeeded"
        handle_payment_succeeded(payload)
      when "gnosis.transaction.executed"
        handle_gnosis_transaction(payload)
      else
        Rails.logger.warn("Evento no reconocido: #{event_type}")
        handle_unknown_event(event_type, payload)
      end
    end
  end

  private

  def handle_user_created(payload)
    User.create!(
      email: payload["email"],
      name: payload["name"],
      external_id: payload["id"]
    )
    Rails.logger.info("Usuario creado: #{payload['email']}")
  end

  def handle_order_completed(payload)
    order = Order.find_by(external_id: payload["order_id"])
    order&.update(status: "completed", completed_at: Time.current)
    Rails.logger.info("Orden completada: #{payload['order_id']}")
  end

  def handle_payment_succeeded(payload)
    payment = Payment.find_by(external_id: payload["payment_id"])
    payment&.update(status: "succeeded", processed_at: Time.current)
    
    # Enviar notificación
    UserNotification.with(
      message: "Pago procesado exitosamente: #{payload['amount']}"
    ).deliver(payment.user)
  end

  def handle_gnosis_transaction(payload)
    transaction_hash = payload["transaction_hash"]
    safe_address = payload["safe_address"]
    
    # Actualizar estado de la transacción multisig
    multisig_tx = MultisigTransaction.find_by(
      transaction_hash: transaction_hash,
      safe_address: safe_address
    )
    
    multisig_tx&.update(status: "executed", executed_at: Time.current)
    
    # Notificar a todos los firmantes
    notify_multisig_execution(multisig_tx) if multisig_tx
  end

  def handle_unknown_event(event_type, payload)
    # Guardar eventos desconocidos para análisis posterior
    UnknownWebhookEvent.create!(
      event_type: event_type,
      payload: payload,
      received_at: Time.current
    )
  end

  def notify_multisig_execution(multisig_tx)
    multisig_tx.signers.each do |signer|
      UserNotification.with(
        message: "Transacción multisig ejecutada: #{multisig_tx.transaction_hash}"
      ).deliver(signer)
    end
  end
end
```

### Configurar Karafka en karafka.rb
```ruby
class KarafkaApp < Karafka::App
  setup do |config|
    config.kafka = {
      'bootstrap.servers': ENV.fetch('KAFKA_BROKERS', 'localhost:9092'),
      'session.timeout.ms': 6000,
      'auto.offset.reset': 'earliest'
    }
    config.client_id = 'portfolio-webhooks'
  end

  consumer_group :webhooks do
    topic :webhooks do
      consumer WebhookConsumer
    end
  end
end
```

🔹 **Añadir archivos al commit:**
```bash
git add .
git commit -m "feat(webhooks): agrega consumidor de eventos para procesar webhooks con Karafka"
```

## 📝 Explicación y Código Generado

### Ejemplo de Uso en Rails Console
```ruby
# Enviar un evento manualmente
Karafka.producer.produce_async(
  topic: "webhooks",
  payload: { email: "test@example.com", name: "Test User" }.to_json,
  key: "user.created"
)
```

### Ejemplo de Recepción de Webhook en API
```bash
curl -X POST "http://localhost:3000/webhooks" \
  -H "X-Event-Type: user.created" \
  -H "Content-Type: application/json" \
  -d '{ "email": "newuser@example.com", "name": "New User" }'
```

### Ejemplo de Procesamiento de Webhooks en Karafka
```bash
# Iniciar el procesador de eventos
bundle exec karafka server

# En otro terminal, iniciar Redpanda
cd infra/redpanda && docker-compose up -d
```

### Monitoreo y Debugging
```ruby
# En Rails Console - Verificar mensajes en cola
Karafka::Admin.cluster_info

# Verificar últimos eventos procesados
UnknownWebhookEvent.recent.limit(10)

# Estadísticas de procesamiento
WebhookConsumer.processed_messages_count
```

## 🔧 Configuración de Producción

### Variables de Entorno
```bash
# Kafka/Redpanda Configuration
KAFKA_BROKERS=redpanda-cluster:9092
KAFKA_SASL_USERNAME=your_username
KAFKA_SASL_PASSWORD=your_password

# Webhook Security
WEBHOOK_SECRET_TOKEN=your_secret_token
```

### Seguridad de Webhooks
```ruby
# En WebhooksController, agregar verificación de firma
def verify_webhook_signature
  signature = request.headers['X-Webhook-Signature']
  payload = request.body.read
  expected = OpenSSL::HMAC.hexdigest('SHA256', webhook_secret, payload)
  
  unless Rack::Utils.secure_compare(signature, "sha256=#{expected}")
    head :unauthorized
    return false
  end
  true
end

private

def webhook_secret
  Rails.application.credentials.webhook_secret_token
end
```