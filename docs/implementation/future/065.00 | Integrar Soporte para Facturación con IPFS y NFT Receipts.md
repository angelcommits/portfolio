# ✅ Paso 65: Integrar Soporte para Facturación con IPFS y NFT Receipts

Ahora agregaremos IPFS para almacenar facturas y NFTs como recibos de pago, permitiendo que cada transacción sea representada por un NFT en la blockchain.
✅ Almacenamiento Descentralizado en IPFS → Facturas almacenadas de manera inmutable.
✅ NFT Receipts (ERC-721) → Generar NFTs como recibos de pago.
✅ Web3.js + Stimulus.js → Para manejar la carga y recuperación de archivos.
✅ Smart Contract en Solidity → Para acuñar NFTs de recibos de pago.
📌 Commit 65.1: Instalar IPFS SDK y Configurar API Keys
🔹 Mensaje de commit:
feat(ipfs-nft): instala IPFS SDK y configura API Keys para almacenar facturas
🔹 Contenido del commit:
Instalar SDK de IPFS
yarn add ipfs-http-client
Configurar Credenciales en config/credentials.yml.enc
ipfs:
  api_url: "https://ipfs.infura.io:5001"
  project_id: "YOUR_INFURA_PROJECT_ID"
  project_secret: "YOUR_INFURA_PROJECT_SECRET"
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(ipfs-nft): instala IPFS SDK y configura API Keys para almacenar facturas"
📌 Commit 65.2: Subir Facturas a IPFS desde el Backend
🔹 Mensaje de commit:
feat(ipfs-nft): agrega API para subir facturas a IPFS desde el backend
🔹 Contenido del commit:
Definir IpfsUploaderService en app/services/ipfs_uploader_service.rb
require "net/http"
require "base64"
class IpfsUploaderService
  INFURA_URL = Rails.application.credentials.dig(:ipfs, :api_url)
  def self.upload(file)
    uri = URI("#{INFURA_URL}/api/v0/add")
    request = Net::HTTP::Post.new(uri)
    request.basic_auth Rails.application.credentials.dig(:ipfs, :project_id), Rails.application.credentials.dig(:ipfs, :project_secret)
    form_data = [["file", file]]
    request.set_form form_data, "multipart/form-data"
    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) { |http| http.request(request) }
    JSON.parse(response.body)["Hash"]
  end
end
Modificar InvoicesController para Soporte IPFS
class InvoicesController < ApplicationController
  def upload
    file = params[:file]
    ipfs_hash = IpfsUploaderService.upload(file)
    Invoice.create!(
      user: current_user,
      ipfs_hash: ipfs_hash,
      filename: file.original_filename
    )
    render json: { message: "Factura subida a IPFS", ipfs_hash: ipfs_hash }
  end
end
Agregar Rutas en config/routes.rb
post "/invoices/upload", to: "invoices#upload"
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(ipfs-nft): agrega API para subir facturas a IPFS desde el backend"
📌 Commit 65.3: Crear Smart Contract para Generar NFT Receipts
🔹 Mensaje de commit:
feat(ipfs-nft): agrega smart contract para acuñar NFTs como recibos de pago
🔹 Contenido del commit:
Definir NFTReceipt.sol en contracts/NFTReceipt.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
contract NFTReceipt is ERC721URIStorage, Ownable {
    uint256 private _tokenIds;
    event ReceiptMinted(address recipient, uint256 tokenId, string ipfsHash);
    constructor() ERC721("NFTReceipt", "NREC") {}
    function mintReceipt(address recipient, string memory ipfsHash) external onlyOwner returns (uint256) {
        _tokenIds++;
        uint256 newTokenId = _tokenIds;
        _mint(recipient, newTokenId);
        _setTokenURI(newTokenId, string(abi.encodePacked("ipfs://", ipfsHash)));
        emit ReceiptMinted(recipient, newTokenId, ipfsHash);
        return newTokenId;
    }
}
Compilar y Desplegar Contrato
npx hardhat compile
npx hardhat run scripts/deploy.js --network goerli
✅ Guardar la dirección del contrato para el backend.
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(ipfs-nft): agrega smart contract para acuñar NFTs como recibos de pago"
📌 Commit 65.4: Integrar Acuñación de NFTs en Frontend con Web3.js
🔹 Mensaje de commit:
feat(ipfs-nft): integra acuñación de NFT Receipts en frontend con Web3.js
🔹 Contenido del commit:
Modificar app/javascript/controllers/nft_receipt_controller.js
import { Controller } from "@hotwired/stimulus";
import Web3 from "web3";
export default class extends Controller {
  static targets = ["invoiceId", "ipfsHash"];
  async mintNFTReceipt() {
    if (!window.ethereum) {
      alert("Por favor instala MetaMask");
      return;
    }
    const web3 = new Web3(window.ethereum);
    await window.ethereum.request({ method: "eth_requestAccounts" });
    const invoiceId = this.invoiceIdTarget.value;
    const ipfsHash = this.ipfsHashTarget.value;
    const contract = new web3.eth.Contract(
      [
        { name: "mintReceipt", type: "function", inputs: [{ name: "recipient", type: "address" }, { name: "ipfsHash", type: "string" }] }
      ],
      "0xYourNFTContractAddress"
    );
    await contract.methods.mintReceipt(window.ethereum.selectedAddress, ipfsHash).send({ from: window.ethereum.selectedAddress });
    alert("NFT de Recibo generado con éxito");
  }
}
Modificar app/views/invoices/index.html.erb
<h2>Acuñar NFT de Recibo</h2>
<label>Invoice ID:</label>
<input type="text" data-nft-receipt-target="invoiceId">
<label>IPFS Hash:</label>
<input type="text" data-nft-receipt-target="ipfsHash">
<button data-controller="nft-receipt" data-action="click->nft-receipt#mintNFTReceipt">
  Generar NFT de Recibo
</button>
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(ipfs-nft): integra acuñación de NFT Receipts en frontend con Web3.js"
📝 Explicación y Código Generado
Ejemplo de Subir Factura a IPFS en API
curl -X POST "http://localhost:3000/invoices/upload" \
  -F "file=@factura.pdf"
✅ Respuesta esperada:
{ "message": "Factura subida a IPFS", "ipfs_hash": "Qm123456..." }
Ejemplo de Acuñación de NFT de Recibo en API
NFTReceipt.mintReceipt("0xUserWallet", "Qm123456...")
✅ Se genera un NFT con la factura almacenada en IPFS.
Ejemplo de Ver NFT en OpenSea (Goerli)
https://testnets.opensea.io/assets/goerli/0xYourNFTContractAddress/1
✅ El usuario puede visualizar su NFT de recibo.
