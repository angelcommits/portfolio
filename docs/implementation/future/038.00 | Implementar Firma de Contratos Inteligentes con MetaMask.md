# ✅ Paso 38: Implementar Firma de Contratos Inteligentes con MetaMask

Ahora agregaremos firma de contratos inteligentes directamente desde la plataforma usando MetaMask, permitiendo a los usuarios autorizar transacciones on-chain con un solo clic.
✅ MetaMask → Permite firmar transacciones directamente desde el navegador.
✅ Smart Contracts en Ethereum/Polygon → Interacción con la blockchain en tiempo real.
✅ Web3.js → Librería para interactuar con contratos inteligentes desde el frontend.
✅ Firma digital EIP-712 → Para transacciones seguras sin necesidad de gas (gasless transactions).
📌 Commit 38.1: Configurar Web3.js y MetaMask en el Frontend
🔹 Mensaje de commit:
feat(smart-contracts): agrega integración con MetaMask y Web3.js para firma de contratos
🔹 Contenido del commit:
Agregar Web3.js en app/javascript/packs/web3.js
import Web3 from "web3";
let web3;
if (window.ethereum) {
  web3 = new Web3(window.ethereum);
  window.ethereum.request({ method: "eth_requestAccounts" });
} else {
  console.log("MetaMask no detectado.");
}
export default web3;
Crear Script para Firma de Contratos en app/javascript/packs/smart_contract.js
import web3 from "./web3";
async function signContract(contractAddress, userAddress, contractHash) {
  if (!web3) return alert("MetaMask no está conectado.");
  const message = `Autorizo la firma del contrato con ID: ${contractHash}`;
  const signature = await web3.eth.personal.sign(message, userAddress);
  fetch("/contracts/sign", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ contract_hash: contractHash, user_address: userAddress, signature: signature })
  })
    .then(response => response.json())
    .then(data => alert(`Contrato firmado exitosamente: ${data.transaction_hash}`))
    .catch(error => console.error("Error firmando contrato:", error));
}
document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".sign-contract").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      const accounts = await web3.eth.getAccounts();
      signContract("0xContractAddress", accounts[0], contractHash);
    });
  });
});
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(smart-contracts): agrega integración con MetaMask y Web3.js para firma de contratos"
📌 Commit 38.2: Crear Smart Contract para Firmar Documentos
🔹 Mensaje de commit:
feat(smart-contracts): agrega contrato inteligente Solidity para firma de documentos
🔹 Contenido del commit:
Crear contracts/DocumentSigner.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract DocumentSigner {
    mapping(bytes32 => bool) public signedContracts;
    event ContractSigned(address indexed signer, bytes32 contractHash);
    function signContract(bytes32 contractHash) public {
        require(!signedContracts[contractHash], "El contrato ya está firmado.");
        signedContracts[contractHash] = true;
        emit ContractSigned(msg.sender, contractHash);
    }
    function verifyContract(bytes32 contractHash) public view returns (bool) {
        return signedContracts[contractHash];
    }
}
Compilar y Desplegar en Testnet (Goerli/Polygon Mumbai)
npx hardhat compile
npx hardhat run scripts/deploy.js --network goerli
✅ Guardar la dirección del contrato en config/credentials.yml.enc.
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(smart-contracts): agrega contrato inteligente Solidity para firma de documentos"
📌 Commit 38.3: Crear Servicio para Interactuar con Smart Contracts
🔹 Mensaje de commit:
feat(smart-contracts): agrega servicio para firmar contratos en Blockchain
🔹 Contenido del commit:
Definir SmartContractService en app/services/smart_contract_service.rb
require "web3"
class SmartContractService
  INFURA_URL = Rails.application.credentials.dig(:ethereum, :infura_url)
  CONTRACT_ADDRESS = Rails.application.credentials.dig(:ethereum, :contract_address)
  def self.sign_contract(user_address, contract_hash, signature)
    web3 = Web3::Eth::Rpc.new(host: INFURA_URL, port: 443, connect_options: { use_ssl: true })
    contract_abi = JSON.parse(File.read(Rails.root.join("config/contract_abi.json")))
    contract = web3.eth.contract(abi: contract_abi).at(CONTRACT_ADDRESS)
    tx = contract.transact_and_wait.signContract(contract_hash, from: user_address, gas: 200_000)
    tx.transaction_hash
  end
  def self.verify_contract(contract_hash)
    web3 = Web3::Eth::Rpc.new(host: INFURA_URL, port: 443, connect_options: { use_ssl: true })
    contract_abi = JSON.parse(File.read(Rails.root.join("config/contract_abi.json")))
    contract = web3.eth.contract(abi: contract_abi).at(CONTRACT_ADDRESS)
    contract.call.verifyContract(contract_hash)
  end
end
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(smart-contracts): agrega servicio para firmar contratos en Blockchain"
📌 Commit 38.4: Agregar Endpoint para Firmar Contratos con Blockchain
🔹 Mensaje de commit:
feat(smart-contracts): agrega endpoint para firmar contratos con MetaMask en Blockchain
🔹 Contenido del commit:
Modificar ContractsController en app/controllers/contracts_controller.rb
class ContractsController < ApplicationController
  def sign
    contract_hash = params[:contract_hash]
    user_address = params[:user_address]
    signature = params[:signature]
    tx_hash = SmartContractService.sign_contract(user_address, contract_hash, signature)
    render json: { message: "Contrato firmado en Blockchain", transaction_hash: tx_hash }
  end
  def verify
    contract_hash = params[:contract_hash]
    exists = SmartContractService.verify_contract(contract_hash)
    if exists
      render json: { message: "Contrato firmado y válido en Blockchain" }, status: :ok
    else
      render json: { error: "Contrato no registrado en Blockchain" }, status: :not_found
    end
  end
end
Agregar Rutas en config/routes.rb
Rails.application.routes.draw do
  post "/contracts/sign", to: "contracts#sign"
  get "/contracts/verify", to: "contracts#verify"
end
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(smart-contracts): agrega endpoint para firmar contratos con MetaMask en Blockchain"
📝 Explicación y Código Generado
Ejemplo de Firma de Contrato en MetaMask
    El usuario hace clic en "Firmar Contrato".
    MetaMask solicita la firma del mensaje.
    El backend registra la firma en la Blockchain.
    Se retorna el transaction_hash como confirmación.
Ejemplo de Firma Manual en Rails Console
SmartContractService.sign_contract("0xUserWallet", "0xContratoHash", "0xFirmaDigital")
Ejemplo de Verificación de Contrato en Blockchain
curl -X GET "http://localhost:3000/contracts/verify?contract_hash=0xContratoHash"
✅ Si el contrato está firmado:
{ "message": "Contrato firmado y válido en Blockchain" }
❌ Si el contrato no existe:
{ "error": "Contrato no registrado en Blockchain" }
