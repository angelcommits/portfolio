# ✅ Paso 41: Integrar Soporte para Trezor en Smart Contracts On-Chain

Ahora agregaremos compatibilidad con Trezor directamente en los Smart Contracts, permitiendo que las transacciones sean verificadas on-chain sin intervención del backend.
✅ EIP-191 / EIP-712 → Soporte para firmas seguras en contratos inteligentes.
✅ Verificación de Firma en Solidity → No depender del backend para validar firmas.
✅ Compatibilidad con Wallets Hardware (Trezor, Ledger) → Máxima seguridad en Blockchain.
📌 Commit 41.1: Modificar Smart Contract para Verificar Firmas con Trezor
🔹 Mensaje de commit:
feat(trezor): agrega verificación de firma en Solidity para soporte de Trezor
🔹 Contenido del commit:
Modificar contracts/DocumentSigner.sol para Validación de Firma
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract DocumentSigner {
    mapping(bytes32 => bool) public signedContracts;
    event ContractSigned(address indexed signer, bytes32 contractHash);
    function signContract(bytes32 contractHash, bytes memory signature) public {
        address signer = recoverSigner(contractHash, signature);
        require(!signedContracts[contractHash], "El contrato ya está firmado.");
        signedContracts[contractHash] = true;
        emit ContractSigned(signer, contractHash);
    }
    function verifyContract(bytes32 contractHash) public view returns (bool) {
        return signedContracts[contractHash];
    }
    function recoverSigner(bytes32 hash, bytes memory signature) public pure returns (address) {
        bytes32 messageHash = prefixed(hash);
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);
        return ecrecover(messageHash, v, r, s);
    }
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
    function splitSignature(bytes memory sig) internal pure returns (uint8, bytes32, bytes32) {
        require(sig.length == 65, "Firma inválida.");
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        return (v, r, s);
    }
}
✅ El contrato ahora valida firmas de Trezor directamente en la Blockchain.
Compilar y Desplegar en Testnet (Goerli/Polygon Mumbai)
npx hardhat compile
npx hardhat run scripts/deploy.js --network polygon_mumbai
✅ Guardar la dirección del contrato en config/credentials.yml.enc.
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(trezor): agrega verificación de firma en Solidity para soporte de Trezor"
📌 Commit 41.2: Modificar Web3.js para Firmar con Trezor y Enviar a la Blockchain
🔹 Mensaje de commit:
feat(trezor): modifica Web3.js para firmar con Trezor y enviar transacción a la Blockchain
🔹 Contenido del commit:
Modificar app/javascript/packs/trezor_sign.js
import TrezorConnect from "./trezor";
import Web3 from "web3";
async function signContractWithTrezorOnChain(contractAddress, contractHash) {
  const response = await TrezorConnect.ethereumSignMessage({
    path: "m/44'/60'/0'/0/0",
    message: contractHash,
    hex: false
  });
  if (response.success) {
    const signature = response.payload.signature;
    const userAddress = response.payload.address;
    const web3 = new Web3(window.ethereum);
    const contractAbi = [ /* ABI del contrato */ ];
    const contract = new web3.eth.Contract(contractAbi, contractAddress);
    const tx = await contract.methods.signContract(contractHash, signature).send({
      from: userAddress,
      gas: 200000
    });
    alert(`Contrato firmado en Blockchain: ${tx.transactionHash}`);
  } else {
    alert("Firma fallida: " + response.payload.error);
  }
}
document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".sign-contract-trezor-onchain").forEach(button => {
    button.addEventListener("click", async (event) => {
      const contractHash = event.target.dataset.contractHash;
      signContractWithTrezorOnChain("0xContractAddress", contractHash);
    });
  });
});
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(trezor): modifica Web3.js para firmar con Trezor y enviar transacción a la Blockchain"
📌 Commit 41.3: Crear Endpoint para Verificar Firmas On-Chain
🔹 Mensaje de commit:
feat(trezor): agrega endpoint para verificar firmas en la Blockchain sin backend
🔹 Contenido del commit:
Modificar ContractsController para Validación On-Chain
class ContractsController < ApplicationController
  def verify_on_chain
    contract_hash = params[:contract_hash]
    exists = SmartContractService.verify_contract(contract_hash)
    if exists
      render json: { message: "Contrato firmado y válido en Blockchain sin backend" }, status: :ok
    else
      render json: { error: "Contrato no registrado en Blockchain" }, status: :not_found
    end
  end
end
Agregar Ruta en config/routes.rb
Rails.application.routes.draw do
  get "/contracts/verify_on_chain", to: "contracts#verify_on_chain"
end
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(trezor): agrega endpoint para verificar firmas en la Blockchain sin backend"
📝 Explicación y Código Generado
Ejemplo de Firma de Contrato con Trezor en Blockchain
    El usuario hace clic en "Firmar Contrato con Trezor On-Chain".
    Trezor Connect solicita la firma del contrato en el hardware wallet.
    El usuario confirma la firma en su dispositivo.
    Web3.js envía la transacción directamente a la Blockchain.
    El contrato inteligente valida la firma en Solidity sin intervención del backend.
Ejemplo de Firma de Contrato On-Chain con Web3.js
signContractWithTrezorOnChain("0xContractAddress", "0xContratoHash");
✅ La firma se almacena directamente en la Blockchain.
Ejemplo de Verificación de Contrato On-Chain
curl -X GET "http://localhost:3000/contracts/verify_on_chain?contract_hash=0xContratoHash"
✅ Si el contrato está firmado:
{ "message": "Contrato firmado y válido en Blockchain sin backend" }
❌ Si el contrato no existe:
{ "error": "Contrato no registrado en Blockchain" }
Ejemplo de Confirmación de Firma en MetaMask/Trezor
signContractWithTrezorOnChain("0xContractAddress", "0xContratoHash");
✅ El usuario firma directamente desde su dispositivo sin exponer claves privadas.
