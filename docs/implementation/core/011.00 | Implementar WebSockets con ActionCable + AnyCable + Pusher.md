# ✅ Paso 11: Implementar WebSockets con ActionCable + AnyCable + Pusher

Ahora agregaremos WebSockets combinando ActionCable, AnyCable y Pusher para manejar notificaciones en tiempo real.
✅ ActionCable → Soporte nativo de Rails para WebSockets.
✅ AnyCable → Mejora el rendimiento en producción con WebSockets y gRPC.
✅ Pusher → Alternativa en caso de clientes que no soporten WebSockets o para escalabilidad.
📌 Commit 11.1: Configurar ActionCable en Rails
🔹 Mensaje de commit:
feat(websockets): configura ActionCable para notificaciones en tiempo real
🔹 Contenido del commit:
# Configurar Redis para manejar conexiones de WebSockets en desarrollo
echo "gem 'redis', '~> 4.8'" >> Gemfile
# Instalar la gema
bundle install
# Configurar ActionCable en `config/cable.yml`
echo "
development:
adapter: redis
url: redis://localhost:6379/1
production:
adapter: any_cable
" > config/cable.yml
# Añadir archivos al commit
git add .
git commit -m "feat(websockets): configura ActionCable para notificaciones en tiempo real"
📌 Commit 11.2: Integrar AnyCable para optimización de WebSockets
🔹 Mensaje de commit:
feat(websockets): agrega AnyCable para mejorar el rendimiento de WebSockets en producción
🔹 Contenido del commit:
# Añadir la gema AnyCable
echo "gem 'anycable-rails', '~> 1.4'" >> Gemfile
# Instalar la gema
bundle install
# Generar la configuración de AnyCable
rails g anycable:setup
# Configurar AnyCable en `config/anycable.yml`
echo "
production:
rpc_host: redis://localhost:6379/2
redis_channel: '**anycable**'
" >> config/anycable.yml
# Añadir archivos al commit
git add .
git commit -m "feat(websockets): agrega AnyCable para mejorar el rendimiento de WebSockets en producción"
📌 Commit 11.3: Configurar Pusher como fallback para WebSockets
🔹 Mensaje de commit:
feat(websockets): integra Pusher como alternativa a WebSockets
🔹 Contenido del commit:
# Añadir la gema Pusher
echo "gem 'pusher', '~> 3.0'" >> Gemfile
# Instalar la gema
bundle install
# Configurar Pusher en `config/initializers/pusher.rb`
echo "
require 'pusher'
Pusher.app_id = ENV['PUSHER_APP_ID']
Pusher.key = ENV['PUSHER_KEY']
Pusher.secret = ENV['PUSHER_SECRET']
Pusher.cluster = ENV['PUSHER_CLUSTER']
Pusher.logger = Rails.logger
Pusher.encrypted = true
" >> config/initializers/pusher.rb
# Añadir archivos al commit
git add .
git commit -m "feat(websockets): integra Pusher como alternativa a WebSockets"
📌 Commit 11.4: Crear un Canal de Notificaciones en ActionCable
🔹 Mensaje de commit:
feat(websockets): agrega un canal de notificaciones en ActionCable
🔹 Contenido del commit:
Definir un Canal de Notificaciones (app/channels/notification_channel.rb)
class NotificationChannel < ApplicationCable::Channel
def subscribed
stream*from "notifications*#{params[:user_id]}"
end
end
Broadcast de una Notificación en Rails Console
ActionCable.server.broadcast("notifications\_#{user.id}", { message: "Tienes una nueva notificación" })
🔹 Añadir archivos al commit:
git add .
git commit -m "feat(websockets): agrega un canal de notificaciones en ActionCable"
📝 Explicación y Código Generado
Ejemplo de Suscripción en JavaScript (app/javascript/channels/notification_channel.js)
import consumer from "./consumer"
consumer.subscriptions.create({ channel: "NotificationChannel", user_id: CURRENT_USER_ID }, {
received(data) {
alert(data.message);
}
});
Ejemplo de Uso en Rails Console
# Enviar una notificación en tiempo real
ActionCable.server.broadcast("notifications\_#{user.id}", { message: "Tienes una nueva tarea pendiente" })
Alternativa con Pusher
Pusher.trigger("notifications\_#{user.id}", "new_notification", { message: "Nuevo mensaje" })
